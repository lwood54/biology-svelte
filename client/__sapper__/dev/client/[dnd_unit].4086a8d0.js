import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, r as validate_each_argument, v as validate_slots, u as validate_store, x as subscribe, y as createEventDispatcher, o as onMount, z as empty, l as insert_dev, A as transition_in, p as noop, b as detach_dev, a as space, e as element, t as text, q as query_selector_all, c as claim_space, f as claim_element, h as children, j as claim_text, B as attr_dev, k as add_location, m as append_dev, n as listen_dev, C as set_data_dev, D as create_out_transition, E as destroy_each, F as run_all, G as null_to_empty, I as add_render_callback, J as create_in_transition, K as component_subscribe, L as group_outros, M as transition_out, N as check_outros, O as create_component, P as claim_component, Q as mount_component, R as destroy_component } from './client.31669433.js';
import { f as fade, a as fly } from './index.67598e49.js';

const dnd_store_data = writable({
	totalCorrect: 0,
	totalWrong: 0,
	round1Correct: 0,
	round1Wrong: 0,
	round2Correct: 0,
	round2Wrong: 0,
	firstLoad: true,
});

const dnd_store = {
	subscribe: dnd_store_data.subscribe,
	incCorrectCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Correct: data.round1Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Correct: data.round2Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			}
		});
	},
	incWrongCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Wrong: data.round1Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Wrong: data.round2Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			}
		});
	},
	resetScores: () => {
		dnd_store_data.set({
			totalCorrect: 0,
			totalWrong: 0,
			round1Correct: 0,
			round1Wrong: 0,
			round2Correct: 0,
			round2Wrong: 0,
			firstLoad: true,
		});
	},
	changeFirstLoad: (newBool) => {
		dnd_store_data.update((data) => {
			const updatedData = {
				...data,
				firstLoad: newBool,
			};
			return updatedData;
		});
	},
};

/* src/components/GameBoard.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "src/components/GameBoard.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	child_ctx[19] = i;
	return child_ctx;
}

// (370:4) {:else}
function create_else_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "img-piece svelte-ctpe5c");
			if (img.src !== (img_src_value = /*piece*/ ctx[17].pic)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*piece*/ ctx[17].alt);
			add_location(img, file, 371, 6, 12062);
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 370, 5, 11967);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);

			if (!mounted) {
				dispose = [
					listen_dev(img, "dragstart", /*dragItem*/ ctx[6], false, false, false),
					listen_dev(img, "drag", /*handleDrag*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && img.src !== (img_src_value = /*piece*/ ctx[17].pic)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*piecesArray*/ 16 && img_alt_value !== (img_alt_value = /*piece*/ ctx[17].alt)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(370:4) {:else}",
		ctx
	});

	return block;
}

// (366:4) {#if piece.definition || piece.hint}
function create_if_block(ctx) {
	let div;

	let t0_value = (/*piece*/ ctx[17].definition
	? /*piece*/ ctx[17].definition
	: /*piece*/ ctx[17].hint) + "";

	let t0;
	let t1;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 366, 5, 11777);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(div, "dragstart", /*dragItem*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && t0_value !== (t0_value = (/*piece*/ ctx[17].definition
			? /*piece*/ ctx[17].definition
			: /*piece*/ ctx[17].hint) + "")) set_data_dev(t0, t0_value);

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(366:4) {#if piece.definition || piece.hint}",
		ctx
	});

	return block;
}

// (365:3) {#each piecesArray as piece, i}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*piece*/ ctx[17].definition || /*piece*/ ctx[17].hint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(365:3) {#each piecesArray as piece, i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let div29;
	let div20;
	let div3;
	let h30;
	let t1_value = /*colHeadings*/ ctx[1].col1Heading + "";
	let t1;
	let t2;
	let div0;
	let t3;
	let div1;
	let t4;
	let div2;
	let t5;
	let div7;
	let h31;
	let t6_value = /*colHeadings*/ ctx[1].col2Heading + "";
	let t6;
	let t7;
	let div4;
	let t8;
	let div5;
	let t9;
	let div6;
	let t10;
	let div11;
	let h32;
	let t11_value = /*colHeadings*/ ctx[1].col3Heading + "";
	let t11;
	let t12;
	let div8;
	let t13;
	let div9;
	let t14;
	let div10;
	let t15;
	let div15;
	let h33;
	let t16_value = /*colHeadings*/ ctx[1].col4Heading + "";
	let t16;
	let t17;
	let div12;
	let t18;
	let div13;
	let t19;
	let div14;
	let t20;
	let div19;
	let h34;
	let t21_value = /*colHeadings*/ ctx[1].col5Heading + "";
	let t21;
	let t22;
	let div16;
	let t23;
	let div17;
	let t24;
	let div18;
	let t25;
	let div28;
	let div25;
	let div21;
	let t26;
	let t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "";
	let t27;
	let t28;
	let div22;
	let t29;
	let t30_value = /*$dnd_store*/ ctx[5].totalWrong + "";
	let t30;
	let t31;
	let div23;
	let t32;
	let t33;
	let t34;

	let t35_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Correct
	: /*$dnd_store*/ ctx[5].round2Correct) + "";

	let t35;
	let t36;
	let div24;
	let t37;
	let t38;
	let t39;

	let t40_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Wrong
	: /*$dnd_store*/ ctx[5].round2Wrong) + "";

	let t40;
	let div25_outro;
	let t41;
	let div26;
	let t42;
	let t43;
	let div26_outro;
	let t44;
	let div27;
	let div27_id_value;
	let current;
	let mounted;
	let dispose;
	document_1.title = title_value = /*title*/ ctx[2];
	let each_value = /*piecesArray*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			t0 = space();
			div29 = element("div");
			div20 = element("div");
			div3 = element("div");
			h30 = element("h3");
			t1 = text(t1_value);
			t2 = space();
			div0 = element("div");
			t3 = space();
			div1 = element("div");
			t4 = space();
			div2 = element("div");
			t5 = space();
			div7 = element("div");
			h31 = element("h3");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			t8 = space();
			div5 = element("div");
			t9 = space();
			div6 = element("div");
			t10 = space();
			div11 = element("div");
			h32 = element("h3");
			t11 = text(t11_value);
			t12 = space();
			div8 = element("div");
			t13 = space();
			div9 = element("div");
			t14 = space();
			div10 = element("div");
			t15 = space();
			div15 = element("div");
			h33 = element("h3");
			t16 = text(t16_value);
			t17 = space();
			div12 = element("div");
			t18 = space();
			div13 = element("div");
			t19 = space();
			div14 = element("div");
			t20 = space();
			div19 = element("div");
			h34 = element("h3");
			t21 = text(t21_value);
			t22 = space();
			div16 = element("div");
			t23 = space();
			div17 = element("div");
			t24 = space();
			div18 = element("div");
			t25 = space();
			div28 = element("div");
			div25 = element("div");
			div21 = element("div");
			t26 = text("total correct: ");
			t27 = text(t27_value);
			t28 = space();
			div22 = element("div");
			t29 = text("total wrong: ");
			t30 = text(t30_value);
			t31 = space();
			div23 = element("div");
			t32 = text("round ");
			t33 = text(/*round*/ ctx[0]);
			t34 = text(" correct: ");
			t35 = text(t35_value);
			t36 = space();
			div24 = element("div");
			t37 = text("round ");
			t38 = text(/*round*/ ctx[0]);
			t39 = text(" wrong: ");
			t40 = text(t40_value);
			t41 = space();
			div26 = element("div");
			t42 = text("Round ");
			t43 = text(/*round*/ ctx[0]);
			t44 = space();
			div27 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1az6e94\"]", document_1.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div29 = claim_element(nodes, "DIV", { class: true });
			var div29_nodes = children(div29);
			div20 = claim_element(div29_nodes, "DIV", { class: true });
			var div20_nodes = children(div20);
			div3 = claim_element(div20_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			h30 = claim_element(div3_nodes, "H3", { class: true });
			var h30_nodes = children(h30);
			t1 = claim_text(h30_nodes, t1_value);
			h30_nodes.forEach(detach_dev);
			t2 = claim_space(div3_nodes);
			div0 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div1).forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div2).forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t5 = claim_space(div20_nodes);
			div7 = claim_element(div20_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			h31 = claim_element(div7_nodes, "H3", { class: true });
			var h31_nodes = children(h31);
			t6 = claim_text(h31_nodes, t6_value);
			h31_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			div4 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div4).forEach(detach_dev);
			t8 = claim_space(div7_nodes);
			div5 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div5).forEach(detach_dev);
			t9 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div6).forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			t10 = claim_space(div20_nodes);
			div11 = claim_element(div20_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h32 = claim_element(div11_nodes, "H3", { class: true });
			var h32_nodes = children(h32);
			t11 = claim_text(h32_nodes, t11_value);
			h32_nodes.forEach(detach_dev);
			t12 = claim_space(div11_nodes);
			div8 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div8).forEach(detach_dev);
			t13 = claim_space(div11_nodes);
			div9 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div9).forEach(detach_dev);
			t14 = claim_space(div11_nodes);
			div10 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div10).forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			t15 = claim_space(div20_nodes);
			div15 = claim_element(div20_nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			h33 = claim_element(div15_nodes, "H3", { class: true });
			var h33_nodes = children(h33);
			t16 = claim_text(h33_nodes, t16_value);
			h33_nodes.forEach(detach_dev);
			t17 = claim_space(div15_nodes);
			div12 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div12).forEach(detach_dev);
			t18 = claim_space(div15_nodes);
			div13 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div13).forEach(detach_dev);
			t19 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div14).forEach(detach_dev);
			div15_nodes.forEach(detach_dev);
			t20 = claim_space(div20_nodes);
			div19 = claim_element(div20_nodes, "DIV", { class: true });
			var div19_nodes = children(div19);
			h34 = claim_element(div19_nodes, "H3", { class: true });
			var h34_nodes = children(h34);
			t21 = claim_text(h34_nodes, t21_value);
			h34_nodes.forEach(detach_dev);
			t22 = claim_space(div19_nodes);
			div16 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div16).forEach(detach_dev);
			t23 = claim_space(div19_nodes);
			div17 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div17).forEach(detach_dev);
			t24 = claim_space(div19_nodes);
			div18 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div18).forEach(detach_dev);
			div19_nodes.forEach(detach_dev);
			div20_nodes.forEach(detach_dev);
			t25 = claim_space(div29_nodes);
			div28 = claim_element(div29_nodes, "DIV", { class: true });
			var div28_nodes = children(div28);
			div25 = claim_element(div28_nodes, "DIV", { class: true });
			var div25_nodes = children(div25);
			div21 = claim_element(div25_nodes, "DIV", { class: true });
			var div21_nodes = children(div21);
			t26 = claim_text(div21_nodes, "total correct: ");
			t27 = claim_text(div21_nodes, t27_value);
			div21_nodes.forEach(detach_dev);
			t28 = claim_space(div25_nodes);
			div22 = claim_element(div25_nodes, "DIV", { class: true });
			var div22_nodes = children(div22);
			t29 = claim_text(div22_nodes, "total wrong: ");
			t30 = claim_text(div22_nodes, t30_value);
			div22_nodes.forEach(detach_dev);
			t31 = claim_space(div25_nodes);
			div23 = claim_element(div25_nodes, "DIV", { class: true });
			var div23_nodes = children(div23);
			t32 = claim_text(div23_nodes, "round ");
			t33 = claim_text(div23_nodes, /*round*/ ctx[0]);
			t34 = claim_text(div23_nodes, " correct: ");
			t35 = claim_text(div23_nodes, t35_value);
			div23_nodes.forEach(detach_dev);
			t36 = claim_space(div25_nodes);
			div24 = claim_element(div25_nodes, "DIV", { class: true });
			var div24_nodes = children(div24);
			t37 = claim_text(div24_nodes, "round ");
			t38 = claim_text(div24_nodes, /*round*/ ctx[0]);
			t39 = claim_text(div24_nodes, " wrong: ");
			t40 = claim_text(div24_nodes, t40_value);
			div24_nodes.forEach(detach_dev);
			div25_nodes.forEach(detach_dev);
			t41 = claim_space(div28_nodes);
			div26 = claim_element(div28_nodes, "DIV", { class: true });
			var div26_nodes = children(div26);
			t42 = claim_text(div26_nodes, "Round ");
			t43 = claim_text(div26_nodes, /*round*/ ctx[0]);
			div26_nodes.forEach(detach_dev);
			t44 = claim_space(div28_nodes);
			div27 = claim_element(div28_nodes, "DIV", { class: true, id: true });
			var div27_nodes = children(div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div27_nodes);
			}

			div27_nodes.forEach(detach_dev);
			div28_nodes.forEach(detach_dev);
			div29_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h30, "class", "colHeading svelte-ctpe5c");
			add_location(h30, file, 322, 3, 9339);
			attr_dev(div0, "id", "t1");
			attr_dev(div0, "class", "target col1 svelte-ctpe5c");
			add_location(div0, file, 323, 3, 9396);
			attr_dev(div1, "id", "t2");
			attr_dev(div1, "class", "target col1 svelte-ctpe5c");
			add_location(div1, file, 324, 3, 9478);
			attr_dev(div2, "id", "t3");
			attr_dev(div2, "class", "target col1 svelte-ctpe5c");
			add_location(div2, file, 325, 3, 9560);
			attr_dev(div3, "class", "column c1 svelte-ctpe5c");
			add_location(div3, file, 321, 2, 9312);
			attr_dev(h31, "class", "colHeading svelte-ctpe5c");
			add_location(h31, file, 328, 3, 9677);
			attr_dev(div4, "id", "t4");
			attr_dev(div4, "class", "target col2 svelte-ctpe5c");
			add_location(div4, file, 329, 3, 9734);
			attr_dev(div5, "id", "t5");
			attr_dev(div5, "class", "target col2 svelte-ctpe5c");
			add_location(div5, file, 330, 3, 9816);
			attr_dev(div6, "id", "t6");
			attr_dev(div6, "class", "target col2 svelte-ctpe5c");
			add_location(div6, file, 331, 3, 9898);
			attr_dev(div7, "class", "column c2 svelte-ctpe5c");
			add_location(div7, file, 327, 2, 9650);
			attr_dev(h32, "class", "colHeading svelte-ctpe5c");
			add_location(h32, file, 334, 3, 10015);
			attr_dev(div8, "id", "t7");
			attr_dev(div8, "class", "target col3 svelte-ctpe5c");
			add_location(div8, file, 335, 3, 10072);
			attr_dev(div9, "id", "t8");
			attr_dev(div9, "class", "target col3 svelte-ctpe5c");
			add_location(div9, file, 336, 3, 10154);
			attr_dev(div10, "id", "t9");
			attr_dev(div10, "class", "target col3 svelte-ctpe5c");
			add_location(div10, file, 337, 3, 10236);
			attr_dev(div11, "class", "column c3 svelte-ctpe5c");
			add_location(div11, file, 333, 2, 9988);
			attr_dev(h33, "class", "colHeading svelte-ctpe5c");
			add_location(h33, file, 340, 3, 10353);
			attr_dev(div12, "id", "t10");
			attr_dev(div12, "class", "target col4 svelte-ctpe5c");
			add_location(div12, file, 341, 3, 10410);
			attr_dev(div13, "id", "t11");
			attr_dev(div13, "class", "target col4 svelte-ctpe5c");
			add_location(div13, file, 342, 3, 10493);
			attr_dev(div14, "id", "t12");
			attr_dev(div14, "class", "target col4 svelte-ctpe5c");
			add_location(div14, file, 343, 3, 10576);
			attr_dev(div15, "class", "column c4 svelte-ctpe5c");
			add_location(div15, file, 339, 2, 10326);
			attr_dev(h34, "class", "colHeading svelte-ctpe5c");
			add_location(h34, file, 346, 3, 10694);
			attr_dev(div16, "id", "t13");
			attr_dev(div16, "class", "target col5 svelte-ctpe5c");
			add_location(div16, file, 347, 3, 10751);
			attr_dev(div17, "id", "t14");
			attr_dev(div17, "class", "target col5 svelte-ctpe5c");
			add_location(div17, file, 348, 3, 10834);
			attr_dev(div18, "id", "t15");
			attr_dev(div18, "class", "target col5 svelte-ctpe5c");
			add_location(div18, file, 349, 3, 10917);
			attr_dev(div19, "class", "column c5 svelte-ctpe5c");
			add_location(div19, file, 345, 2, 10667);
			attr_dev(div20, "class", "target-container svelte-ctpe5c");
			add_location(div20, file, 320, 1, 9279);
			attr_dev(div21, "class", "score-item svelte-ctpe5c");
			add_location(div21, file, 355, 3, 11102);
			attr_dev(div22, "class", "score-item svelte-ctpe5c");
			add_location(div22, file, 356, 3, 11176);
			attr_dev(div23, "class", "score-item svelte-ctpe5c");
			add_location(div23, file, 357, 3, 11246);
			attr_dev(div24, "class", "score-item svelte-ctpe5c");
			add_location(div24, file, 358, 3, 11370);
			attr_dev(div25, "class", "score-container svelte-ctpe5c");
			add_location(div25, file, 354, 2, 11041);
			attr_dev(div26, "class", "round-label svelte-ctpe5c");
			add_location(div26, file, 361, 2, 11497);
			attr_dev(div27, "class", "pieces-container svelte-ctpe5c");
			attr_dev(div27, "id", div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2");
			add_location(div27, file, 363, 2, 11573);
			attr_dev(div28, "class", "game-bar svelte-ctpe5c");
			add_location(div28, file, 353, 1, 11016);
			attr_dev(div29, "class", "game-page svelte-ctpe5c");
			add_location(div29, file, 319, 0, 9211);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div29, anchor);
			append_dev(div29, div20);
			append_dev(div20, div3);
			append_dev(div3, h30);
			append_dev(h30, t1);
			append_dev(div3, t2);
			append_dev(div3, div0);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div20, t5);
			append_dev(div20, div7);
			append_dev(div7, h31);
			append_dev(h31, t6);
			append_dev(div7, t7);
			append_dev(div7, div4);
			append_dev(div7, t8);
			append_dev(div7, div5);
			append_dev(div7, t9);
			append_dev(div7, div6);
			append_dev(div20, t10);
			append_dev(div20, div11);
			append_dev(div11, h32);
			append_dev(h32, t11);
			append_dev(div11, t12);
			append_dev(div11, div8);
			append_dev(div11, t13);
			append_dev(div11, div9);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div20, t15);
			append_dev(div20, div15);
			append_dev(div15, h33);
			append_dev(h33, t16);
			append_dev(div15, t17);
			append_dev(div15, div12);
			append_dev(div15, t18);
			append_dev(div15, div13);
			append_dev(div15, t19);
			append_dev(div15, div14);
			append_dev(div20, t20);
			append_dev(div20, div19);
			append_dev(div19, h34);
			append_dev(h34, t21);
			append_dev(div19, t22);
			append_dev(div19, div16);
			append_dev(div19, t23);
			append_dev(div19, div17);
			append_dev(div19, t24);
			append_dev(div19, div18);
			append_dev(div29, t25);
			append_dev(div29, div28);
			append_dev(div28, div25);
			append_dev(div25, div21);
			append_dev(div21, t26);
			append_dev(div21, t27);
			append_dev(div25, t28);
			append_dev(div25, div22);
			append_dev(div22, t29);
			append_dev(div22, t30);
			append_dev(div25, t31);
			append_dev(div25, div23);
			append_dev(div23, t32);
			append_dev(div23, t33);
			append_dev(div23, t34);
			append_dev(div23, t35);
			append_dev(div25, t36);
			append_dev(div25, div24);
			append_dev(div24, t37);
			append_dev(div24, t38);
			append_dev(div24, t39);
			append_dev(div24, t40);
			append_dev(div28, t41);
			append_dev(div28, div26);
			append_dev(div26, t42);
			append_dev(div26, t43);
			append_dev(div28, t44);
			append_dev(div28, div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div27, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div0, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div1, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div1, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div2, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div2, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div4, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div4, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div5, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div5, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div6, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div6, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div8, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div8, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div9, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div9, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div10, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div10, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div12, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div12, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div13, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div13, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div14, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div14, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div16, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div16, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div17, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div17, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div18, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div18, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div27, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div27, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div29, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div29, "dragover", /*allowDrop*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 4) && title_value !== (title_value = /*title*/ ctx[2])) {
				document_1.title = title_value;
			}

			if ((!current || dirty & /*colHeadings*/ 2) && t1_value !== (t1_value = /*colHeadings*/ ctx[1].col1Heading + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t6_value !== (t6_value = /*colHeadings*/ ctx[1].col2Heading + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t11_value !== (t11_value = /*colHeadings*/ ctx[1].col3Heading + "")) set_data_dev(t11, t11_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t16_value !== (t16_value = /*colHeadings*/ ctx[1].col4Heading + "")) set_data_dev(t16, t16_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t21_value !== (t21_value = /*colHeadings*/ ctx[1].col5Heading + "")) set_data_dev(t21, t21_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t27_value !== (t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "")) set_data_dev(t27, t27_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t30_value !== (t30_value = /*$dnd_store*/ ctx[5].totalWrong + "")) set_data_dev(t30, t30_value);
			if (!current || dirty & /*round*/ 1) set_data_dev(t33, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t35_value !== (t35_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Correct
			: /*$dnd_store*/ ctx[5].round2Correct) + "")) set_data_dev(t35, t35_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t38, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t40_value !== (t40_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Wrong
			: /*$dnd_store*/ ctx[5].round2Wrong) + "")) set_data_dev(t40, t40_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t43, /*round*/ ctx[0]);

			if (dirty & /*piecesArray, dragItem, handleDrag*/ 592) {
				each_value = /*piecesArray*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div27, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*round*/ 1 && div27_id_value !== (div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2")) {
				attr_dev(div27, "id", div27_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (div25_outro) div25_outro.end(1);
			if (div26_outro) div26_outro.end(1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			div25_outro = create_out_transition(div25, fade, { duration: 10 });
			div26_outro = create_out_transition(div26, fade, { duration: 10 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div29);
			if (detaching && div25_outro) div25_outro.end();
			if (detaching && div26_outro) div26_outro.end();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $dnd_store,
		$$unsubscribe_dnd_store = noop,
		$$subscribe_dnd_store = () => ($$unsubscribe_dnd_store(), $$unsubscribe_dnd_store = subscribe(dnd_store, $$value => $$invalidate(5, $dnd_store = $$value)), dnd_store);

	$$self.$$.on_destroy.push(() => $$unsubscribe_dnd_store());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameBoard", slots, []);
	let { colHeadings } = $$props;
	let { pieces } = $$props;
	let { round } = $$props;
	let { title } = $$props;
	let { dnd_store } = $$props;
	validate_store(dnd_store, "dnd_store");
	$$subscribe_dnd_store();
	let piecesArray = [];
	let piecesLeft = 30;
	const dispatch = createEventDispatcher();

	onMount(() => {
		$$invalidate(4, piecesArray = [...pieces]);
		$$invalidate(4, piecesArray = shuffleArray(piecesArray));

		// firstLoad starts as true, and is immediately turned false
		// this will affect score reset onMount so that round 2 is not reset
		// but reset will happen when coming back after game is over
		dnd_store.changeFirstLoad(false);
	});

	const shuffleArray = array => {
		// copy array to manipulate
		let arrayCopy = [...array];

		let mixedArray = [];

		// loop through copy until no elements left
		while (arrayCopy.length > 0) {
			let randNum = Math.floor(Math.random() * arrayCopy.length);

			// add removed elements to mixedArray as looping occurs
			mixedArray.push(arrayCopy.splice(randNum, 1)[0]);
		}

		return mixedArray;
	};

	const dragItem = e => {
		if (e.target.tagName === "IMG") {
			e.dataTransfer.setData("text", e.target.parentNode.id);
		} else {
			e.dataTransfer.setData("text", e.target.id);
		}
	};

	const dropItem = e => {
		// define pieces container to allow drop of item back into original spot
		let isPiecesContainer = hasClass(e.target, "pieces-container");

		// let parent = e.target.parentNode;
		let dragItemId = e.dataTransfer.getData("text");

		let dragItem = document.getElementById(dragItemId);

		// if target to drop in is empty or the target is the pices container, you can drop item in
		if (!e.target.firstChild || isPiecesContainer) {
			// if the target is not the pieces container
			if (!isPiecesContainer) {
				// setting to static position so the div will be relative to parent
				dragItem.style.position = "static";

				// must make visible again because I am hadding all stacked pieces in
				// the pieces container to display only the top piece so as to not
				// stack box-shadows
				dragItem.style.visibility = "visible";

				//
				if (// check if parent has the odd numbered classes to adjust font color
				hasClass(e.target, "col1") || hasClass(e.target, "col3") || hasClass(e.target, "col5")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#0d223f"; // navy blue
					dragItem.style.color = "#77bc43";
				} else if (hasClass(e.target, "col2") || hasClass(e.target, "col4")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#77bc43"; // green
					dragItem.style.color = "#0d223f";
				}

				if (!checkIsMatch(e.target, dragItem)) {
					dnd_store.incWrongCount(round);
					e.target.style.backgroundColor = "#bf1d1d"; // bg = red
					dragItem.style.color = "#e8e1e1"; // font color = light gray
				} else if (checkIsMatch(e.target, dragItem)) {
					dnd_store.incCorrectCount(round);

					//using children[0] works for image, but I do want to check the node, not just child elem.
					// so children[0] results in break
					console.log("dragItem", dragItem.children);

					if (dragItem.childNodes[0].tagName === "IMG") {
						console.log("this is an image: ", dragItem);
						dragItem.childNodes[0].setAttribute("draggable", "false");
						dragItem.childNodes[0].style.cursor = "no-drop";
						dragItem.style.maxHeight = "110px";
					} else {
						dragItem.style.overflow = "auto";
					}

					dragItem.setAttribute("draggable", "false");
					dragItem.style.border = "none";
					dragItem.style.userSelect = "none";
					dragItem.style.boxShadow = "none";
					dragItem.style.cursor = "no-drop";
				}
			} else if (isPiecesContainer) {
				// if being placed back in the pieces container, going back to absolute and resetting bkgrnd & font color
				dragItem.style.position = "absolute";

				dragItem.style.backgroundColor = "rgb(115, 167, 167)";
				dragItem.style.color = "rgb(15, 21, 21)";
			}

			// now the actual placement occurs
			e.preventDefault();

			e.target.appendChild(dragItem);

			let piecesCont = round === 1
			? document.getElementById("piecesCont1")
			: document.getElementById("piecesCont2");

			$$invalidate(11, piecesLeft = checkPiecesLeft(piecesCont));
		}
	};

	const allowDrop = e => {
		e.preventDefault();
	};

	const handleDrag = e => {
		e.target.style.cursor = "grabbing";
	};

	const checkIsMatch = (target, dragItem) => {
		if (hasClass(target, "col1") && hasClass(dragItem, "col1")) {
			return true;
		} else if (hasClass(target, "col2") && hasClass(dragItem, "col2")) {
			return true;
		} else if (hasClass(target, "col3") && hasClass(dragItem, "col3")) {
			return true;
		} else if (hasClass(target, "col4") && hasClass(dragItem, "col4")) {
			return true;
		} else if (hasClass(target, "col5") && hasClass(dragItem, "col5")) {
			return true;
		} else {
			return false;
		}
	};

	const hasClass = (el, clss) => {
		return el.classList.contains(clss);
	};

	const checkPiecesLeft = el => {
		const numChildNodes = el.childNodes.length;
		return numChildNodes;
	};

	const writable_props = ["colHeadings", "pieces", "round", "title", "dnd_store"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GameBoard> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
	};

	$$self.$capture_state = () => ({
		onMount,
		createEventDispatcher,
		fade,
		colHeadings,
		pieces,
		round,
		title,
		dnd_store,
		piecesArray,
		piecesLeft,
		dispatch,
		shuffleArray,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		checkIsMatch,
		hasClass,
		checkPiecesLeft,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
		if ("piecesArray" in $$props) $$invalidate(4, piecesArray = $$props.piecesArray);
		if ("piecesLeft" in $$props) $$invalidate(11, piecesLeft = $$props.piecesLeft);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*piecesLeft, round*/ 2049) {
			 if (piecesLeft <= 15) {
				// if current round is 1, then change to 2, else change to 3
				$$invalidate(0, round = round === 1 ? 2 : 3);

				dispatch("checkround", round);
			}
		}

		if ($$self.$$.dirty & /*$dnd_store, round, dnd_store*/ 41) {
			 {
				if (!$dnd_store.firstLoad && round === 1) {
					// reset only if game has been loaded and user is back to round 1
					dnd_store.resetScores();
				}
			}
		}
	};

	return [
		round,
		colHeadings,
		title,
		dnd_store,
		piecesArray,
		$dnd_store,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		pieces
	];
}

class GameBoard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			colHeadings: 1,
			pieces: 10,
			round: 0,
			title: 2,
			dnd_store: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameBoard",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*colHeadings*/ ctx[1] === undefined && !("colHeadings" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'colHeadings'");
		}

		if (/*pieces*/ ctx[10] === undefined && !("pieces" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'pieces'");
		}

		if (/*round*/ ctx[0] === undefined && !("round" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'round'");
		}

		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'title'");
		}

		if (/*dnd_store*/ ctx[3] === undefined && !("dnd_store" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'dnd_store'");
		}
	}

	get colHeadings() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colHeadings(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pieces() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pieces(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dnd_store() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_store(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/GameOver.svelte generated by Svelte v3.29.0 */

const file$1 = "src/components/GameOver.svelte";

function create_fragment$1(ctx) {
	let div;
	let h1;
	let t0;
	let t1;
	let h40;
	let t2;
	let t3;
	let t4;
	let h41;
	let t5;
	let t6;
	let t7;
	let h42;
	let t8;
	let t9;

	const block = {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Game Over");
			t1 = space();
			h40 = element("h4");
			t2 = text("Total Correct: ");
			t3 = text(/*totalCorrect*/ ctx[0]);
			t4 = space();
			h41 = element("h4");
			t5 = text("Total Wrong: ");
			t6 = text(/*totalWrong*/ ctx[1]);
			t7 = space();
			h42 = element("h4");
			t8 = text("Final Score: ");
			t9 = text(/*finalScore*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Game Over");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			h40 = claim_element(div_nodes, "H4", { class: true });
			var h40_nodes = children(h40);
			t2 = claim_text(h40_nodes, "Total Correct: ");
			t3 = claim_text(h40_nodes, /*totalCorrect*/ ctx[0]);
			h40_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			h41 = claim_element(div_nodes, "H4", { class: true });
			var h41_nodes = children(h41);
			t5 = claim_text(h41_nodes, "Total Wrong: ");
			t6 = claim_text(h41_nodes, /*totalWrong*/ ctx[1]);
			h41_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			h42 = claim_element(div_nodes, "H4", { class: true });
			var h42_nodes = children(h42);
			t8 = claim_text(h42_nodes, "Final Score: ");
			t9 = claim_text(h42_nodes, /*finalScore*/ ctx[2]);
			h42_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "title svelte-1g63pp");
			add_location(h1, file$1, 29, 1, 518);
			attr_dev(h40, "class", "score-content svelte-1g63pp");
			add_location(h40, file$1, 30, 1, 552);
			attr_dev(h41, "class", "score-content svelte-1g63pp");
			add_location(h41, file$1, 31, 1, 614);
			attr_dev(h42, "class", "score-content svelte-1g63pp");
			add_location(h42, file$1, 32, 1, 672);
			attr_dev(div, "class", "game-over_container svelte-1g63pp");
			add_location(div, file$1, 28, 0, 483);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t0);
			append_dev(div, t1);
			append_dev(div, h40);
			append_dev(h40, t2);
			append_dev(h40, t3);
			append_dev(div, t4);
			append_dev(div, h41);
			append_dev(h41, t5);
			append_dev(h41, t6);
			append_dev(div, t7);
			append_dev(div, h42);
			append_dev(h42, t8);
			append_dev(h42, t9);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*totalCorrect*/ 1) set_data_dev(t3, /*totalCorrect*/ ctx[0]);
			if (dirty & /*totalWrong*/ 2) set_data_dev(t6, /*totalWrong*/ ctx[1]);
			if (dirty & /*finalScore*/ 4) set_data_dev(t9, /*finalScore*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameOver", slots, []);
	let { totalCorrect } = $$props;
	let { totalWrong } = $$props;
	let finalScore;
	const writable_props = ["totalCorrect", "totalWrong"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GameOver> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
	};

	$$self.$capture_state = () => ({ totalCorrect, totalWrong, finalScore });

	$$self.$inject_state = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
		if ("finalScore" in $$props) $$invalidate(2, finalScore = $$props.finalScore);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*totalWrong*/ 2) {
			 {
				let calcScore = Math.round((30 - totalWrong) / 30 * 100);
				$$invalidate(2, finalScore = calcScore >= 0 ? calcScore : 0);
			}
		}
	};

	return [totalCorrect, totalWrong, finalScore];
}

class GameOver extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { totalCorrect: 0, totalWrong: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameOver",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*totalCorrect*/ ctx[0] === undefined && !("totalCorrect" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalCorrect'");
		}

		if (/*totalWrong*/ ctx[1] === undefined && !("totalWrong" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalWrong'");
		}
	}

	get totalCorrect() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalCorrect(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get totalWrong() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalWrong(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/DnD.svelte generated by Svelte v3.29.0 */
const file$2 = "src/components/DnD.svelte";

// (26:29) 
function create_if_block_2(ctx) {
	let div;
	let gameover;
	let div_intro;
	let current;

	gameover = new GameOver({
			props: {
				totalCorrect: /*$dnd_store*/ ctx[5].totalCorrect,
				totalWrong: /*$dnd_store*/ ctx[5].totalWrong
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameover.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameover.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 26, 1, 1133);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameover, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameover_changes = {};
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalCorrect = /*$dnd_store*/ ctx[5].totalCorrect;
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalWrong = /*$dnd_store*/ ctx[5].totalWrong;
			gameover.$set(gameover_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameover.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { y: 200, delay: 600 });
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(gameover.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameover);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(26:29) ",
		ctx
	});

	return block;
}

// (22:29) 
function create_if_block_1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 22, 1, 899);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { delay: 600, duration: 500 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fly, { x: 200, duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(22:29) ",
		ctx
	});

	return block;
}

// (18:0) {#if updatedRound === 1}
function create_if_block$1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 18, 1, 684);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { duration: 300 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fade, { duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(18:0) {#if updatedRound === 1}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*updatedRound*/ ctx[1] === 1) return 0;
		if (/*updatedRound*/ ctx[1] === 2) return 1;
		if (/*updatedRound*/ ctx[1] === 3) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $dnd_store;
	validate_store(dnd_store, "dnd_store");
	component_subscribe($$self, dnd_store, $$value => $$invalidate(5, $dnd_store = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DnD", slots, []);
	let { dnd_content } = $$props;

	// TS/Svelte requires this pattern for reactive declarations (https://blog.scottlogic.com/2020/07/24/svelte-ts.html)
	let updatedRound;

	let colHeadings;

	const updateRound = e => {
		$$invalidate(1, updatedRound = e.detail);
	};

	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DnD> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({
		dnd_store,
		GameBoard,
		fade,
		fly,
		GameOver,
		dnd_content,
		updatedRound,
		colHeadings,
		updateRound,
		pieces,
		round,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
		if ("updatedRound" in $$props) $$invalidate(1, updatedRound = $$props.updatedRound);
		if ("colHeadings" in $$props) $$invalidate(2, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(3, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(4, round = $$props.round);
	};

	let pieces;
	let round;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(2, colHeadings = updatedRound === 1
			? dnd_content.dndgame1
			: dnd_content.dndgame2);
		}

		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(3, pieces = updatedRound === 1
			? dnd_content.pieces1
			: dnd_content.pieces2);
		}

		if ($$self.$$.dirty & /*updatedRound*/ 2) {
			 $$invalidate(4, round = updatedRound);
		}
	};

	 $$invalidate(1, updatedRound = 1);
	return [dnd_content, updatedRound, colHeadings, pieces, round, $dnd_store, updateRound];
}

class DnD extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DnD",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<DnD> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<DnD>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<DnD>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/dndgame/[dnd_unit].svelte generated by Svelte v3.29.0 */

function create_fragment$3(ctx) {
	let title_value;
	let t;
	let dnd;
	let current;
	document.title = title_value = /*dnd_content*/ ctx[0].title;

	dnd = new DnD({
			props: { dnd_content: /*dnd_content*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t = space();
			create_component(dnd.$$.fragment);
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-8wlx8a\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(dnd.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			mount_component(dnd, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*dnd_content*/ 1) && title_value !== (title_value = /*dnd_content*/ ctx[0].title)) {
				document.title = title_value;
			}

			const dnd_changes = {};
			if (dirty & /*dnd_content*/ 1) dnd_changes.dnd_content = /*dnd_content*/ ctx[0];
			dnd.$set(dnd_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dnd.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dnd.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			destroy_component(dnd, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload(page, session) {
	const { dnd_unit } = page.params;
	const res = await this.fetch(`data/${dnd_unit}.json`);
	const dnd_content = await res.json();
	return { dnd_content };
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("U5Bdnd_unitu5D", slots, []);
	let { dnd_content } = $$props; // this gets defined in script module above
	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bdnd_unitu5D> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({ preload, DnD, dnd_content });

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dnd_content];
}

class U5Bdnd_unitu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bdnd_unitu5D",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<U5Bdnd_unitu5D> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bdnd_unitu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2RuZF91bml0XS40MDg2YThkMC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3Jlcy9kbmRfZ2FtZV9zdG9yZS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0dhbWVCb2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9HYW1lT3Zlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9EbkQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kbmRnYW1lL1tkbmRfdW5pdF0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBkbmRfc3RvcmVfZGF0YSA9IHdyaXRhYmxlKHtcblx0dG90YWxDb3JyZWN0OiAwLFxuXHR0b3RhbFdyb25nOiAwLFxuXHRyb3VuZDFDb3JyZWN0OiAwLFxuXHRyb3VuZDFXcm9uZzogMCxcblx0cm91bmQyQ29ycmVjdDogMCxcblx0cm91bmQyV3Jvbmc6IDAsXG5cdGZpcnN0TG9hZDogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZG5kX3N0b3JlID0ge1xuXHRzdWJzY3JpYmU6IGRuZF9zdG9yZV9kYXRhLnN1YnNjcmliZSxcblx0aW5jQ29ycmVjdENvdW50OiAocm91bmQpID0+IHtcblx0XHRkbmRfc3RvcmVfZGF0YS51cGRhdGUoKGRhdGEpID0+IHtcblx0XHRcdGlmIChyb3VuZCA9PT0gMSkge1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0XHQuLi5kYXRhLFxuXHRcdFx0XHRcdHJvdW5kMUNvcnJlY3Q6IGRhdGEucm91bmQxQ29ycmVjdCArIDEsXG5cdFx0XHRcdFx0dG90YWxDb3JyZWN0OiBkYXRhLnRvdGFsQ29ycmVjdCArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJDb3JyZWN0OiBkYXRhLnJvdW5kMkNvcnJlY3QgKyAxLFxuXHRcdFx0XHRcdHRvdGFsQ29ycmVjdDogZGF0YS50b3RhbENvcnJlY3QgKyAxLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlZERhdGE7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGluY1dyb25nQ291bnQ6IChyb3VuZCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnVwZGF0ZSgoZGF0YSkgPT4ge1xuXHRcdFx0aWYgKHJvdW5kID09PSAxKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuXHRcdFx0XHRcdC4uLmRhdGEsXG5cdFx0XHRcdFx0cm91bmQxV3Jvbmc6IGRhdGEucm91bmQxV3JvbmcgKyAxLFxuXHRcdFx0XHRcdHRvdGFsV3Jvbmc6IGRhdGEudG90YWxXcm9uZyArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJXcm9uZzogZGF0YS5yb3VuZDJXcm9uZyArIDEsXG5cdFx0XHRcdFx0dG90YWxXcm9uZzogZGF0YS50b3RhbFdyb25nICsgMSxcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZWREYXRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRyZXNldFNjb3JlczogKCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnNldCh7XG5cdFx0XHR0b3RhbENvcnJlY3Q6IDAsXG5cdFx0XHR0b3RhbFdyb25nOiAwLFxuXHRcdFx0cm91bmQxQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMVdyb25nOiAwLFxuXHRcdFx0cm91bmQyQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMldyb25nOiAwLFxuXHRcdFx0Zmlyc3RMb2FkOiB0cnVlLFxuXHRcdH0pO1xuXHR9LFxuXHRjaGFuZ2VGaXJzdExvYWQ6IChuZXdCb29sKSA9PiB7XG5cdFx0ZG5kX3N0b3JlX2RhdGEudXBkYXRlKChkYXRhKSA9PiB7XG5cdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0Zmlyc3RMb2FkOiBuZXdCb29sLFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHR9KTtcblx0fSxcbn07XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0ZXhwb3J0IGxldCBjb2xIZWFkaW5ncztcblx0ZXhwb3J0IGxldCBwaWVjZXM7XG5cdGV4cG9ydCBsZXQgcm91bmQ7XG5cdGV4cG9ydCBsZXQgdGl0bGU7XG5cdGV4cG9ydCBsZXQgZG5kX3N0b3JlO1xuXHRsZXQgcGllY2VzQXJyYXkgPSBbXTtcblx0bGV0IHBpZWNlc0xlZnQgPSAzMDtcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0JDogaWYgKHBpZWNlc0xlZnQgPD0gMTUpIHtcblx0XHQvLyBpZiBjdXJyZW50IHJvdW5kIGlzIDEsIHRoZW4gY2hhbmdlIHRvIDIsIGVsc2UgY2hhbmdlIHRvIDNcblx0XHRyb3VuZCA9IHJvdW5kID09PSAxID8gMiA6IDM7XG5cdFx0ZGlzcGF0Y2goXCJjaGVja3JvdW5kXCIsIHJvdW5kKTtcblx0fVxuXHQkOiB7XG5cdFx0aWYgKCEkZG5kX3N0b3JlLmZpcnN0TG9hZCAmJiByb3VuZCA9PT0gMSkge1xuXHRcdFx0Ly8gcmVzZXQgb25seSBpZiBnYW1lIGhhcyBiZWVuIGxvYWRlZCBhbmQgdXNlciBpcyBiYWNrIHRvIHJvdW5kIDFcblx0XHRcdGRuZF9zdG9yZS5yZXNldFNjb3JlcygpO1xuXHRcdH1cblx0fVxuXHRvbk1vdW50KCgpID0+IHtcblx0XHRwaWVjZXNBcnJheSA9IFsuLi5waWVjZXNdO1xuXHRcdHBpZWNlc0FycmF5ID0gc2h1ZmZsZUFycmF5KHBpZWNlc0FycmF5KTtcblx0XHQvLyBmaXJzdExvYWQgc3RhcnRzIGFzIHRydWUsIGFuZCBpcyBpbW1lZGlhdGVseSB0dXJuZWQgZmFsc2Vcblx0XHQvLyB0aGlzIHdpbGwgYWZmZWN0IHNjb3JlIHJlc2V0IG9uTW91bnQgc28gdGhhdCByb3VuZCAyIGlzIG5vdCByZXNldFxuXHRcdC8vIGJ1dCByZXNldCB3aWxsIGhhcHBlbiB3aGVuIGNvbWluZyBiYWNrIGFmdGVyIGdhbWUgaXMgb3ZlclxuXHRcdGRuZF9zdG9yZS5jaGFuZ2VGaXJzdExvYWQoZmFsc2UpO1xuXHR9KTtcblx0Y29uc3Qgc2h1ZmZsZUFycmF5ID0gKGFycmF5KSA9PiB7XG5cdFx0Ly8gY29weSBhcnJheSB0byBtYW5pcHVsYXRlXG5cdFx0bGV0IGFycmF5Q29weSA9IFsuLi5hcnJheV07XG5cdFx0bGV0IG1peGVkQXJyYXkgPSBbXTtcblx0XHQvLyBsb29wIHRocm91Z2ggY29weSB1bnRpbCBubyBlbGVtZW50cyBsZWZ0XG5cdFx0d2hpbGUgKGFycmF5Q29weS5sZW5ndGggPiAwKSB7XG5cdFx0XHRsZXQgcmFuZE51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Q29weS5sZW5ndGgpO1xuXHRcdFx0Ly8gYWRkIHJlbW92ZWQgZWxlbWVudHMgdG8gbWl4ZWRBcnJheSBhcyBsb29waW5nIG9jY3Vyc1xuXHRcdFx0bWl4ZWRBcnJheS5wdXNoKGFycmF5Q29weS5zcGxpY2UocmFuZE51bSwgMSlbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWl4ZWRBcnJheTtcblx0fTtcblx0Y29uc3QgZHJhZ0l0ZW0gPSAoZSkgPT4ge1xuXHRcdGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIklNR1wiKSB7XG5cdFx0XHRlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBlLnRhcmdldC5wYXJlbnROb2RlLmlkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgZS50YXJnZXQuaWQpO1xuXHRcdH1cblx0fTtcblx0Y29uc3QgZHJvcEl0ZW0gPSAoZSkgPT4ge1xuXHRcdC8vIGRlZmluZSBwaWVjZXMgY29udGFpbmVyIHRvIGFsbG93IGRyb3Agb2YgaXRlbSBiYWNrIGludG8gb3JpZ2luYWwgc3BvdFxuXHRcdGxldCBpc1BpZWNlc0NvbnRhaW5lciA9IGhhc0NsYXNzKGUudGFyZ2V0LCBcInBpZWNlcy1jb250YWluZXJcIik7XG5cdFx0Ly8gbGV0IHBhcmVudCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0bGV0IGRyYWdJdGVtSWQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dFwiKTtcblx0XHRsZXQgZHJhZ0l0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmFnSXRlbUlkKTtcblx0XHQvLyBpZiB0YXJnZXQgdG8gZHJvcCBpbiBpcyBlbXB0eSBvciB0aGUgdGFyZ2V0IGlzIHRoZSBwaWNlcyBjb250YWluZXIsIHlvdSBjYW4gZHJvcCBpdGVtIGluXG5cdFx0aWYgKCFlLnRhcmdldC5maXJzdENoaWxkIHx8IGlzUGllY2VzQ29udGFpbmVyKSB7XG5cdFx0XHQvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCB0aGUgcGllY2VzIGNvbnRhaW5lclxuXHRcdFx0aWYgKCFpc1BpZWNlc0NvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBzZXR0aW5nIHRvIHN0YXRpYyBwb3NpdGlvbiBzbyB0aGUgZGl2IHdpbGwgYmUgcmVsYXRpdmUgdG8gcGFyZW50XG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcblx0XHRcdFx0Ly8gbXVzdCBtYWtlIHZpc2libGUgYWdhaW4gYmVjYXVzZSBJIGFtIGhhZGRpbmcgYWxsIHN0YWNrZWQgcGllY2VzIGluXG5cdFx0XHRcdC8vIHRoZSBwaWVjZXMgY29udGFpbmVyIHRvIGRpc3BsYXkgb25seSB0aGUgdG9wIHBpZWNlIHNvIGFzIHRvIG5vdFxuXHRcdFx0XHQvLyBzdGFjayBib3gtc2hhZG93c1xuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHRoZSBvZGQgbnVtYmVyZWQgY2xhc3NlcyB0byBhZGp1c3QgZm9udCBjb2xvclxuXHRcdFx0XHRcdGhhc0NsYXNzKGUudGFyZ2V0LCBcImNvbDFcIikgfHxcblx0XHRcdFx0XHRoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2wzXCIpIHx8XG5cdFx0XHRcdFx0aGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sNVwiKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0ZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMGQyMjNmXCI7IC8vIG5hdnkgYmx1ZVxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjNzdiYzQzXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sMlwiKSB8fCBoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2w0XCIpKSB7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHRcdFx0XHRcdGUudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzc3YmM0M1wiOyAvLyBncmVlblxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjMGQyMjNmXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjaGVja0lzTWF0Y2goZS50YXJnZXQsIGRyYWdJdGVtKSkge1xuXHRcdFx0XHRcdGRuZF9zdG9yZS5pbmNXcm9uZ0NvdW50KHJvdW5kKTtcblx0XHRcdFx0XHRlLnRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNiZjFkMWRcIjsgLy8gYmcgPSByZWRcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5jb2xvciA9IFwiI2U4ZTFlMVwiOyAvLyBmb250IGNvbG9yID0gbGlnaHQgZ3JheVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNoZWNrSXNNYXRjaChlLnRhcmdldCwgZHJhZ0l0ZW0pKSB7XG5cdFx0XHRcdFx0ZG5kX3N0b3JlLmluY0NvcnJlY3RDb3VudChyb3VuZCk7XG5cdFx0XHRcdFx0Ly91c2luZyBjaGlsZHJlblswXSB3b3JrcyBmb3IgaW1hZ2UsIGJ1dCBJIGRvIHdhbnQgdG8gY2hlY2sgdGhlIG5vZGUsIG5vdCBqdXN0IGNoaWxkIGVsZW0uXG5cdFx0XHRcdFx0Ly8gc28gY2hpbGRyZW5bMF0gcmVzdWx0cyBpbiBicmVha1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZHJhZ0l0ZW1cIiwgZHJhZ0l0ZW0uY2hpbGRyZW4pO1xuXHRcdFx0XHRcdGlmIChkcmFnSXRlbS5jaGlsZE5vZGVzWzBdLnRhZ05hbWUgPT09IFwiSU1HXCIpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwidGhpcyBpcyBhbiBpbWFnZTogXCIsIGRyYWdJdGVtKTtcblx0XHRcdFx0XHRcdGRyYWdJdGVtLmNoaWxkTm9kZXNbMF0uc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIik7XG5cdFx0XHRcdFx0XHRkcmFnSXRlbS5jaGlsZE5vZGVzWzBdLnN0eWxlLmN1cnNvciA9IFwibm8tZHJvcFwiO1xuXHRcdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUubWF4SGVpZ2h0ID0gXCIxMTBweFwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkcmFnSXRlbS5zZXRBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIiwgXCJmYWxzZVwiKTtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCI7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYm94U2hhZG93ID0gXCJub25lXCI7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuY3Vyc29yID0gXCJuby1kcm9wXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaXNQaWVjZXNDb250YWluZXIpIHtcblx0XHRcdFx0Ly8gaWYgYmVpbmcgcGxhY2VkIGJhY2sgaW4gdGhlIHBpZWNlcyBjb250YWluZXIsIGdvaW5nIGJhY2sgdG8gYWJzb2x1dGUgYW5kIHJlc2V0dGluZyBia2dybmQgJiBmb250IGNvbG9yXG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYigxMTUsIDE2NywgMTY3KVwiO1xuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5jb2xvciA9IFwicmdiKDE1LCAyMSwgMjEpXCI7XG5cdFx0XHR9XG5cdFx0XHQvLyBub3cgdGhlIGFjdHVhbCBwbGFjZW1lbnQgb2NjdXJzXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnRhcmdldC5hcHBlbmRDaGlsZChkcmFnSXRlbSk7XG5cdFx0XHRsZXQgcGllY2VzQ29udCA9IHJvdW5kID09PSAxID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwaWVjZXNDb250MVwiKSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGllY2VzQ29udDJcIik7XG5cdFx0XHRwaWVjZXNMZWZ0ID0gY2hlY2tQaWVjZXNMZWZ0KHBpZWNlc0NvbnQpO1xuXHRcdH1cblx0fTtcblx0Y29uc3QgYWxsb3dEcm9wID0gKGUpID0+IHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdH07XG5cdGNvbnN0IGhhbmRsZURyYWcgPSAoZSkgPT4ge1xuXHRcdGUudGFyZ2V0LnN0eWxlLmN1cnNvciA9IFwiZ3JhYmJpbmdcIjtcblx0fTtcblx0Y29uc3QgY2hlY2tJc01hdGNoID0gKHRhcmdldCwgZHJhZ0l0ZW0pID0+IHtcblx0XHRpZiAoaGFzQ2xhc3ModGFyZ2V0LCBcImNvbDFcIikgJiYgaGFzQ2xhc3MoZHJhZ0l0ZW0sIFwiY29sMVwiKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsIFwiY29sMlwiKSAmJiBoYXNDbGFzcyhkcmFnSXRlbSwgXCJjb2wyXCIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgXCJjb2wzXCIpICYmIGhhc0NsYXNzKGRyYWdJdGVtLCBcImNvbDNcIikpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBcImNvbDRcIikgJiYgaGFzQ2xhc3MoZHJhZ0l0ZW0sIFwiY29sNFwiKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsIFwiY29sNVwiKSAmJiBoYXNDbGFzcyhkcmFnSXRlbSwgXCJjb2w1XCIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblx0Y29uc3QgaGFzQ2xhc3MgPSAoZWwsIGNsc3MpID0+IHtcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsc3MpO1xuXHR9O1xuXHRjb25zdCBjaGVja1BpZWNlc0xlZnQgPSAoZWwpID0+IHtcblx0XHRjb25zdCBudW1DaGlsZE5vZGVzID0gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG5cdFx0cmV0dXJuIG51bUNoaWxkTm9kZXM7XG5cdH07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHRAaW1wb3J0IHVybChcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9U3BhcnRhbjp3Z2h0QDEwMDsyMDA7MzAwOzQwMDs1MDAmZGlzcGxheT1zd2FwXCIpO1xuXHQqIHtcblx0XHRmb250LWZhbWlseTogXCJTcGFydGFuXCIsIHNhbnMtc2VyaWY7XG5cdH1cblx0LmdhbWUtcGFnZSB7XG5cdFx0aGVpZ2h0OiA2NTBweDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRtaW4td2lkdGg6IDgzMHB4O1xuXHRcdG1heC13aWR0aDogMTUwMHB4O1xuXHRcdG1hcmdpbjogYXV0bztcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHR9XG5cdC5nYW1lLWJhciB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0bWFyZ2luOiAwLjc1cmVtO1xuXHR9XG5cdC5waWVjZXMtY29udGFpbmVyIHtcblx0XHRoZWlnaHQ6IDE0NXB4O1xuXHRcdC8qIHdpZHRoOiAyNSU7ICovXG5cdFx0d2lkdGg6IDMwMHB4O1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcblx0XHRhbGlnbi1pdGVtczogZmxleC1zdGFydDtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdH1cblx0LnBpZWNlcyB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IHRvcDtcblx0XHRoZWlnaHQ6IDExMHB4O1xuXHRcdG1heC13aWR0aDogOTAlO1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdC8qIHBhZGRpbmctdG9wOiAxMHB4OyAqL1xuXHRcdHBhZGRpbmc6IDUlIDUlIDAgNSU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2Q4ZDhkODtcblx0XHRjb2xvcjogIzMxNDU0MTtcblx0XHRsaW5lLWhlaWdodDogMS4xNXJlbTtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Y3Vyc29yOiBncmFiO1xuXHRcdGJveC1zaGFkb3c6IDFweCAycHggM3B4IGJsYWNrO1xuXHRcdHZpc2liaWxpdHk6IGhpZGRlbjtcblx0fVxuXHQvKiBvbmx5IHNob3cgZmlyc3QgZGl2IGluIGNvbnRhaW5lciBoZWxwcyBwcmV2ZW50XG4gIHN0YWNraW5nIHVwIG9mIGJveC1zaGFkb3dcbiAgTk9URTogbWFrZSBzdXJlIHRvIGhhdmUgYW55IGRyb3BwZWQgZGl2cyBpbiB0YXJnZXRzIHZpc2libGUgKi9cblx0LnBpZWNlcy1jb250YWluZXIgZGl2OmZpcnN0LW9mLXR5cGUge1xuXHRcdHZpc2liaWxpdHk6IHZpc2libGU7XG5cdH1cblx0LnBpZWNlczo6LXdlYmtpdC1zY3JvbGxiYXIge1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdH1cblx0LnBpZWNlcy50ZXh0IHtcblx0XHRvdmVyZmxvdzogYXV0bztcblx0fVxuXHQuaW1nLWNvbnRhaW5lciB7XG5cdFx0bWF4LWhlaWdodDogMTMwcHg7XG5cdFx0cGFkZGluZzogMXB4O1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0Ym94LXNoYWRvdzogMXB4IDJweCAzcHggYmxhY2s7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0fVxuXHQuaW1nLXBpZWNlIHtcblx0XHQvKiBtYXgtaGVpZ2h0OiAxMjBweDsgKi9cblx0XHRtYXgtaGVpZ2h0OiA5MCU7XG5cdFx0LyogaGVpZ2h0OiBhdXRvOyAqL1xuXHRcdC8qIG1heC13aWR0aDogMTAwJTsgKi9cblx0XHRtaW4td2lkdGg6IDc1cHg7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0bWFyZ2luOiAwIDVweDtcblx0XHQvKiB3aWR0aDogOTAlOyAqL1xuXHR9XG5cdC5zY29yZS1jb250YWluZXIge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG5cdH1cblx0LnNjb3JlLWl0ZW0ge1xuXHRcdG1hcmdpbi1ib3R0b206IDAuNnJlbTtcblx0fVxuXHQucm91bmQtbGFiZWwge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRoZWlnaHQ6IDExNHB4O1xuXHRcdGZvbnQtc2l6ZTogM3JlbTtcblx0fVxuXHQudGFyZ2V0LWNvbnRhaW5lciB7XG5cdFx0aGVpZ2h0OiA3MCU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdGZsZXgtd3JhcDogd3JhcDtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdG1hcmdpbjogMDtcblx0fVxuXHQudGFyZ2V0IHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGhlaWdodDogMTMwcHg7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHR9XG5cdC5jb2x1bW4ge1xuXHRcdHdpZHRoOiAxOSU7XG5cdFx0bWF4LWhlaWdodDogMTAwJTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0YWxpZ24tY29udGVudDogY2VudGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRtYXJnaW46IDAgMC4yNXJlbTtcblx0XHRtYXJnaW46IDA7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXHQuYzEgLnRhcmdldCxcblx0LmMzIC50YXJnZXQsXG5cdC5jNSAudGFyZ2V0IHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjMGQyMjNmO1xuXHRcdGNvbG9yOiAjNzdiYzQzO1xuXHR9XG5cdC5jMiAudGFyZ2V0LFxuXHQuYzQgLnRhcmdldCB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogIzc3YmM0Mztcblx0XHRjb2xvcjogIzBkMjIzZjtcblx0fVxuXHQuY29sSGVhZGluZyB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdG1hcmdpbjogMDtcblx0XHRoZWlnaHQ6IDM1cHg7XG5cdFx0Zm9udC1zaXplOiAxcmVtO1xuXHR9XG5cdC5jMSAuY29sSGVhZGluZyxcblx0LmMzIC5jb2xIZWFkaW5nLFxuXHQuYzUgLmNvbEhlYWRpbmcge1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICM3N2JjNDM7XG5cdH1cblx0LmMyIC5jb2xIZWFkaW5nLFxuXHQuYzQgLmNvbEhlYWRpbmcge1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICMwZDIyM2Y7XG5cdFx0Y29sb3I6ICM3N2JjNDM7XG5cdH1cblx0QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTEyMHB4KSB7XG5cdFx0LnBpZWNlcy1jb250YWluZXIge1xuXHRcdFx0bWFyZ2luLWxlZnQ6IDhweDtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPnt0aXRsZX08L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPGRpdiBjbGFzcz1cImdhbWUtcGFnZVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfT5cblx0PGRpdiBjbGFzcz1cInRhcmdldC1jb250YWluZXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uIGMxXCI+XG5cdFx0XHQ8aDMgY2xhc3M9XCJjb2xIZWFkaW5nXCI+e2NvbEhlYWRpbmdzLmNvbDFIZWFkaW5nfTwvaDM+XG5cdFx0XHQ8ZGl2IGlkPVwidDFcIiBjbGFzcz1cInRhcmdldCBjb2wxXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDJcIiBjbGFzcz1cInRhcmdldCBjb2wxXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDNcIiBjbGFzcz1cInRhcmdldCBjb2wxXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImNvbHVtbiBjMlwiPlxuXHRcdFx0PGgzIGNsYXNzPVwiY29sSGVhZGluZ1wiPntjb2xIZWFkaW5ncy5jb2wySGVhZGluZ308L2gzPlxuXHRcdFx0PGRpdiBpZD1cInQ0XCIgY2xhc3M9XCJ0YXJnZXQgY29sMlwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQ1XCIgY2xhc3M9XCJ0YXJnZXQgY29sMlwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQ2XCIgY2xhc3M9XCJ0YXJnZXQgY29sMlwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4gYzNcIj5cblx0XHRcdDxoMyBjbGFzcz1cImNvbEhlYWRpbmdcIj57Y29sSGVhZGluZ3MuY29sM0hlYWRpbmd9PC9oMz5cblx0XHRcdDxkaXYgaWQ9XCJ0N1wiIGNsYXNzPVwidGFyZ2V0IGNvbDNcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0OFwiIGNsYXNzPVwidGFyZ2V0IGNvbDNcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0OVwiIGNsYXNzPVwidGFyZ2V0IGNvbDNcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uIGM0XCI+XG5cdFx0XHQ8aDMgY2xhc3M9XCJjb2xIZWFkaW5nXCI+e2NvbEhlYWRpbmdzLmNvbDRIZWFkaW5nfTwvaDM+XG5cdFx0XHQ8ZGl2IGlkPVwidDEwXCIgY2xhc3M9XCJ0YXJnZXQgY29sNFwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQxMVwiIGNsYXNzPVwidGFyZ2V0IGNvbDRcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTJcIiBjbGFzcz1cInRhcmdldCBjb2w0XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImNvbHVtbiBjNVwiPlxuXHRcdFx0PGgzIGNsYXNzPVwiY29sSGVhZGluZ1wiPntjb2xIZWFkaW5ncy5jb2w1SGVhZGluZ308L2gzPlxuXHRcdFx0PGRpdiBpZD1cInQxM1wiIGNsYXNzPVwidGFyZ2V0IGNvbDVcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTRcIiBjbGFzcz1cInRhcmdldCBjb2w1XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDE1XCIgY2xhc3M9XCJ0YXJnZXQgY29sNVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwiZ2FtZS1iYXJcIj5cblx0XHQ8ZGl2IG91dDpmYWRlPXt7IGR1cmF0aW9uOiAxMCB9fSBjbGFzcz1cInNjb3JlLWNvbnRhaW5lclwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cInNjb3JlLWl0ZW1cIj50b3RhbCBjb3JyZWN0OiB7JGRuZF9zdG9yZS50b3RhbENvcnJlY3R9PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2NvcmUtaXRlbVwiPnRvdGFsIHdyb25nOiB7JGRuZF9zdG9yZS50b3RhbFdyb25nfTwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cInNjb3JlLWl0ZW1cIj5yb3VuZCB7cm91bmR9IGNvcnJlY3Q6IHtyb3VuZCA9PT0gMSA/ICRkbmRfc3RvcmUucm91bmQxQ29ycmVjdCA6ICRkbmRfc3RvcmUucm91bmQyQ29ycmVjdH08L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJzY29yZS1pdGVtXCI+cm91bmQge3JvdW5kfSB3cm9uZzoge3JvdW5kID09PSAxID8gJGRuZF9zdG9yZS5yb3VuZDFXcm9uZyA6ICRkbmRfc3RvcmUucm91bmQyV3Jvbmd9PC9kaXY+XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwicm91bmQtbGFiZWxcIiBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogMTAgfX0+Um91bmQge3JvdW5kfTwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInBpZWNlcy1jb250YWluZXJcIiBpZD17cm91bmQgPT09IDEgPyAncGllY2VzQ29udDEnIDogJ3BpZWNlc0NvbnQyJ30gb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9PlxuXHRcdFx0eyNlYWNoIHBpZWNlc0FycmF5IGFzIHBpZWNlLCBpfVxuXHRcdFx0XHR7I2lmIHBpZWNlLmRlZmluaXRpb24gfHwgcGllY2UuaGludH1cblx0XHRcdFx0XHQ8ZGl2IGluOmZhZGUgaWQ9e3BpZWNlLmlkfSBjbGFzcz17YHBpZWNlcyAke3BpZWNlLmNvbH0gdGV4dGB9IGRyYWdnYWJsZT1cInRydWVcIiBvbjpkcmFnc3RhcnQ9e2RyYWdJdGVtfT5cblx0XHRcdFx0XHRcdHtwaWVjZS5kZWZpbml0aW9uID8gcGllY2UuZGVmaW5pdGlvbiA6IHBpZWNlLmhpbnR9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHQ8ZGl2IGluOmZhZGUgaWQ9e3BpZWNlLmlkfSBjbGFzcz17YHBpZWNlcyAke3BpZWNlLmNvbH0gaW1nLWNvbnRhaW5lcmB9IGRyYWdnYWJsZT1cInRydWVcIj5cblx0XHRcdFx0XHRcdDxpbWcgY2xhc3M9XCJpbWctcGllY2VcIiBzcmM9e3BpZWNlLnBpY30gYWx0PXtwaWVjZS5hbHR9IG9uOmRyYWdzdGFydD17ZHJhZ0l0ZW19IG9uOmRyYWc9e2hhbmRsZURyYWd9IC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRleHBvcnQgbGV0IHRvdGFsQ29ycmVjdDogbnVtYmVyO1xuXHRleHBvcnQgbGV0IHRvdGFsV3Jvbmc6IG51bWJlcjtcblxuXHRsZXQgZmluYWxTY29yZTogbnVtYmVyO1xuXHQkOiB7XG5cdFx0bGV0IGNhbGNTY29yZSA9IE1hdGgucm91bmQoKCgzMCAtIHRvdGFsV3JvbmcpIC8gMzApICogMTAwKTtcblx0XHRmaW5hbFNjb3JlID0gY2FsY1Njb3JlID49IDAgPyBjYWxjU2NvcmUgOiAwO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuZ2FtZS1vdmVyX2NvbnRhaW5lciB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiA1MHZoO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC13cmFwOiB3cmFwO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdH1cblx0LnRpdGxlIHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cblx0LnNjb3JlLWNvbnRlbnQge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImdhbWUtb3Zlcl9jb250YWluZXJcIj5cblx0PGgxIGNsYXNzPVwidGl0bGVcIj5HYW1lIE92ZXI8L2gxPlxuXHQ8aDQgY2xhc3M9XCJzY29yZS1jb250ZW50XCI+VG90YWwgQ29ycmVjdDoge3RvdGFsQ29ycmVjdH08L2g0PlxuXHQ8aDQgY2xhc3M9XCJzY29yZS1jb250ZW50XCI+VG90YWwgV3Jvbmc6IHt0b3RhbFdyb25nfTwvaDQ+XG5cdDxoNCBjbGFzcz1cInNjb3JlLWNvbnRlbnRcIj5GaW5hbCBTY29yZToge2ZpbmFsU2NvcmV9PC9oND5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZG5kX3N0b3JlIH0gZnJvbSBcIi4uL3N0b3Jlcy9kbmRfZ2FtZV9zdG9yZVwiO1xuXHRpbXBvcnQgR2FtZUJvYXJkIGZyb20gXCIuL0dhbWVCb2FyZC5zdmVsdGVcIjtcblx0aW1wb3J0IHsgZmFkZSwgZmx5IH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG5cdGltcG9ydCBHYW1lT3ZlciBmcm9tIFwiLi9HYW1lT3Zlci5zdmVsdGVcIjtcblxuXHRleHBvcnQgbGV0IGRuZF9jb250ZW50O1xuXHQvLyBUUy9TdmVsdGUgcmVxdWlyZXMgdGhpcyBwYXR0ZXJuIGZvciByZWFjdGl2ZSBkZWNsYXJhdGlvbnMgKGh0dHBzOi8vYmxvZy5zY290dGxvZ2ljLmNvbS8yMDIwLzA3LzI0L3N2ZWx0ZS10cy5odG1sKVxuXHRsZXQgdXBkYXRlZFJvdW5kOiBudW1iZXI7XG5cdCQ6IHVwZGF0ZWRSb3VuZCA9IDE7XG5cblx0aW50ZXJmYWNlIENvbEhlYWRpbmdzIHtcblx0XHRjb2wxSGVhZGluZzogc3RyaW5nO1xuXHRcdGNvbDJIZWFkaW5nOiBzdHJpbmc7XG5cdFx0Y29sM0hlYWRpbmc6IHN0cmluZztcblx0XHRjb2w0SGVhZGluZzogc3RyaW5nO1xuXHRcdGNvbDVIZWFkaW5nOiBzdHJpbmc7XG5cdH1cblx0bGV0IGNvbEhlYWRpbmdzOiBDb2xIZWFkaW5ncztcblx0JDogY29sSGVhZGluZ3MgPSB1cGRhdGVkUm91bmQgPT09IDEgPyBkbmRfY29udGVudC5kbmRnYW1lMSA6IGRuZF9jb250ZW50LmRuZGdhbWUyO1xuXHQkOiBwaWVjZXMgPSB1cGRhdGVkUm91bmQgPT09IDEgPyBkbmRfY29udGVudC5waWVjZXMxIDogZG5kX2NvbnRlbnQucGllY2VzMjtcblx0JDogcm91bmQgPSB1cGRhdGVkUm91bmQ7XG5cblx0Y29uc3QgdXBkYXRlUm91bmQgPSAoZSkgPT4ge1xuXHRcdHVwZGF0ZWRSb3VuZCA9IGUuZGV0YWlsO1xuXHR9O1xuPC9zY3JpcHQ+XG5cbnsjaWYgdXBkYXRlZFJvdW5kID09PSAxfVxuXHQ8ZGl2IGluOmZhZGU9e3sgZHVyYXRpb246IDMwMCB9fSBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogNTAwIH19PlxuXHRcdDxHYW1lQm9hcmQge2RuZF9zdG9yZX0gdGl0bGU9e2RuZF9jb250ZW50LnRpdGxlfSB7Y29sSGVhZGluZ3N9IHtwaWVjZXN9IG9uOmNoZWNrcm91bmQ9e3VwZGF0ZVJvdW5kfSB7cm91bmR9IC8+XG5cdDwvZGl2PlxuezplbHNlIGlmIHVwZGF0ZWRSb3VuZCA9PT0gMn1cblx0PGRpdiBpbjpmYWRlPXt7IGRlbGF5OiA2MDAsIGR1cmF0aW9uOiA1MDAgfX0gb3V0OmZseT17eyB4OiAyMDAsIGR1cmF0aW9uOiA1MDAgfX0+XG5cdFx0PEdhbWVCb2FyZCB7ZG5kX3N0b3JlfSB0aXRsZT17ZG5kX2NvbnRlbnQudGl0bGV9IHtjb2xIZWFkaW5nc30ge3BpZWNlc30gb246Y2hlY2tyb3VuZD17dXBkYXRlUm91bmR9IHtyb3VuZH0gLz5cblx0PC9kaXY+XG57OmVsc2UgaWYgdXBkYXRlZFJvdW5kID09PSAzfVxuXHQ8ZGl2IGluOmZseT17eyB5OiAyMDAsIGRlbGF5OiA2MDAgfX0+XG5cdFx0PEdhbWVPdmVyIHRvdGFsQ29ycmVjdD17JGRuZF9zdG9yZS50b3RhbENvcnJlY3R9IHRvdGFsV3Jvbmc9eyRkbmRfc3RvcmUudG90YWxXcm9uZ30gLz5cblx0PC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKHBhZ2UsIHNlc3Npb24pIHtcblx0XHRjb25zdCB7IGRuZF91bml0IH0gPSBwYWdlLnBhcmFtcztcblx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKGBkYXRhLyR7ZG5kX3VuaXR9Lmpzb25gKTtcblx0XHRjb25zdCBkbmRfY29udGVudCA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0cmV0dXJuIHsgZG5kX2NvbnRlbnQgfTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCBEbkQgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvRG5ELnN2ZWx0ZVwiO1xuXHRleHBvcnQgbGV0IGRuZF9jb250ZW50OyAvLyB0aGlzIGdldHMgZGVmaW5lZCBpbiBzY3JpcHQgbW9kdWxlIGFib3ZlXG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e2RuZF9jb250ZW50LnRpdGxlfTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48RG5EIHtkbmRfY29udGVudH0gLz5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUM7QUFDaEMsQ0FBQyxZQUFZLEVBQUUs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
