import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, r as validate_each_argument, v as validate_slots, u as validate_store, x as subscribe, y as createEventDispatcher, o as onMount, g as globals, z as empty, l as insert_dev, A as transition_in, p as noop, b as detach_dev, a as space, e as element, t as text, q as query_selector_all, c as claim_space, f as claim_element, h as children, j as claim_text, B as attr_dev, k as add_location, m as append_dev, n as listen_dev, C as set_data_dev, D as create_out_transition, E as destroy_each, F as run_all, G as null_to_empty, I as add_render_callback, J as create_in_transition, K as component_subscribe, L as group_outros, M as transition_out, N as check_outros, O as create_component, P as claim_component, Q as mount_component, R as destroy_component } from './client.5be5c957.js';
import { f as fade, a as fly } from './index.5103a136.js';

const dnd_store_data = writable({
	totalCorrect: 0,
	totalWrong: 0,
	round1Correct: 0,
	round1Wrong: 0,
	round2Correct: 0,
	round2Wrong: 0,
	firstLoad: true,
});

const dnd_store = {
	subscribe: dnd_store_data.subscribe,
	incCorrectCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Correct: data.round1Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Correct: data.round2Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			}
		});
	},
	incWrongCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Wrong: data.round1Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Wrong: data.round2Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			}
		});
	},
	resetScores: () => {
		dnd_store_data.set({
			totalCorrect: 0,
			totalWrong: 0,
			round1Correct: 0,
			round1Wrong: 0,
			round2Correct: 0,
			round2Wrong: 0,
			firstLoad: true,
		});
	},
	changeFirstLoad: (newBool) => {
		dnd_store_data.update((data) => {
			const updatedData = {
				...data,
				firstLoad: newBool,
			};
			return updatedData;
		});
	},
};

/* src/components/GameBoard.svelte generated by Svelte v3.29.0 */

const { document: document_1 } = globals;
const file = "src/components/GameBoard.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	child_ctx[19] = i;
	return child_ctx;
}

// (369:4) {:else}
function create_else_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "img-piece svelte-ctpe5c");
			if (img.src !== (img_src_value = /*piece*/ ctx[17].pic)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*piece*/ ctx[17].alt);
			add_location(img, file, 370, 6, 11950);
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 369, 5, 11855);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);

			if (!mounted) {
				dispose = [
					listen_dev(img, "dragstart", /*dragItem*/ ctx[6], false, false, false),
					listen_dev(img, "drag", /*handleDrag*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && img.src !== (img_src_value = /*piece*/ ctx[17].pic)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*piecesArray*/ 16 && img_alt_value !== (img_alt_value = /*piece*/ ctx[17].alt)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(369:4) {:else}",
		ctx
	});

	return block;
}

// (365:4) {#if piece.definition || piece.hint}
function create_if_block(ctx) {
	let div;

	let t0_value = (/*piece*/ ctx[17].definition
	? /*piece*/ ctx[17].definition
	: /*piece*/ ctx[17].hint) + "";

	let t0;
	let t1;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 365, 5, 11665);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(div, "dragstart", /*dragItem*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && t0_value !== (t0_value = (/*piece*/ ctx[17].definition
			? /*piece*/ ctx[17].definition
			: /*piece*/ ctx[17].hint) + "")) set_data_dev(t0, t0_value);

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(365:4) {#if piece.definition || piece.hint}",
		ctx
	});

	return block;
}

// (364:3) {#each piecesArray as piece, i}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*piece*/ ctx[17].definition || /*piece*/ ctx[17].hint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(364:3) {#each piecesArray as piece, i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let div29;
	let div20;
	let div3;
	let h30;
	let t1_value = /*colHeadings*/ ctx[1].col1Heading + "";
	let t1;
	let t2;
	let div0;
	let t3;
	let div1;
	let t4;
	let div2;
	let t5;
	let div7;
	let h31;
	let t6_value = /*colHeadings*/ ctx[1].col2Heading + "";
	let t6;
	let t7;
	let div4;
	let t8;
	let div5;
	let t9;
	let div6;
	let t10;
	let div11;
	let h32;
	let t11_value = /*colHeadings*/ ctx[1].col3Heading + "";
	let t11;
	let t12;
	let div8;
	let t13;
	let div9;
	let t14;
	let div10;
	let t15;
	let div15;
	let h33;
	let t16_value = /*colHeadings*/ ctx[1].col4Heading + "";
	let t16;
	let t17;
	let div12;
	let t18;
	let div13;
	let t19;
	let div14;
	let t20;
	let div19;
	let h34;
	let t21_value = /*colHeadings*/ ctx[1].col5Heading + "";
	let t21;
	let t22;
	let div16;
	let t23;
	let div17;
	let t24;
	let div18;
	let t25;
	let div28;
	let div25;
	let div21;
	let t26;
	let t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "";
	let t27;
	let t28;
	let div22;
	let t29;
	let t30_value = /*$dnd_store*/ ctx[5].totalWrong + "";
	let t30;
	let t31;
	let div23;
	let t32;
	let t33;
	let t34;

	let t35_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Correct
	: /*$dnd_store*/ ctx[5].round2Correct) + "";

	let t35;
	let t36;
	let div24;
	let t37;
	let t38;
	let t39;

	let t40_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Wrong
	: /*$dnd_store*/ ctx[5].round2Wrong) + "";

	let t40;
	let div25_outro;
	let t41;
	let div26;
	let t42;
	let t43;
	let div26_outro;
	let t44;
	let div27;
	let div27_id_value;
	let current;
	let mounted;
	let dispose;
	document_1.title = title_value = /*title*/ ctx[2];
	let each_value = /*piecesArray*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			t0 = space();
			div29 = element("div");
			div20 = element("div");
			div3 = element("div");
			h30 = element("h3");
			t1 = text(t1_value);
			t2 = space();
			div0 = element("div");
			t3 = space();
			div1 = element("div");
			t4 = space();
			div2 = element("div");
			t5 = space();
			div7 = element("div");
			h31 = element("h3");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			t8 = space();
			div5 = element("div");
			t9 = space();
			div6 = element("div");
			t10 = space();
			div11 = element("div");
			h32 = element("h3");
			t11 = text(t11_value);
			t12 = space();
			div8 = element("div");
			t13 = space();
			div9 = element("div");
			t14 = space();
			div10 = element("div");
			t15 = space();
			div15 = element("div");
			h33 = element("h3");
			t16 = text(t16_value);
			t17 = space();
			div12 = element("div");
			t18 = space();
			div13 = element("div");
			t19 = space();
			div14 = element("div");
			t20 = space();
			div19 = element("div");
			h34 = element("h3");
			t21 = text(t21_value);
			t22 = space();
			div16 = element("div");
			t23 = space();
			div17 = element("div");
			t24 = space();
			div18 = element("div");
			t25 = space();
			div28 = element("div");
			div25 = element("div");
			div21 = element("div");
			t26 = text("total correct: ");
			t27 = text(t27_value);
			t28 = space();
			div22 = element("div");
			t29 = text("total wrong: ");
			t30 = text(t30_value);
			t31 = space();
			div23 = element("div");
			t32 = text("round ");
			t33 = text(/*round*/ ctx[0]);
			t34 = text(" correct: ");
			t35 = text(t35_value);
			t36 = space();
			div24 = element("div");
			t37 = text("round ");
			t38 = text(/*round*/ ctx[0]);
			t39 = text(" wrong: ");
			t40 = text(t40_value);
			t41 = space();
			div26 = element("div");
			t42 = text("Round ");
			t43 = text(/*round*/ ctx[0]);
			t44 = space();
			div27 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1az6e94\"]", document_1.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div29 = claim_element(nodes, "DIV", { class: true });
			var div29_nodes = children(div29);
			div20 = claim_element(div29_nodes, "DIV", { class: true });
			var div20_nodes = children(div20);
			div3 = claim_element(div20_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			h30 = claim_element(div3_nodes, "H3", { class: true });
			var h30_nodes = children(h30);
			t1 = claim_text(h30_nodes, t1_value);
			h30_nodes.forEach(detach_dev);
			t2 = claim_space(div3_nodes);
			div0 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div1).forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div2).forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t5 = claim_space(div20_nodes);
			div7 = claim_element(div20_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			h31 = claim_element(div7_nodes, "H3", { class: true });
			var h31_nodes = children(h31);
			t6 = claim_text(h31_nodes, t6_value);
			h31_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			div4 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div4).forEach(detach_dev);
			t8 = claim_space(div7_nodes);
			div5 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div5).forEach(detach_dev);
			t9 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div6).forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			t10 = claim_space(div20_nodes);
			div11 = claim_element(div20_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h32 = claim_element(div11_nodes, "H3", { class: true });
			var h32_nodes = children(h32);
			t11 = claim_text(h32_nodes, t11_value);
			h32_nodes.forEach(detach_dev);
			t12 = claim_space(div11_nodes);
			div8 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div8).forEach(detach_dev);
			t13 = claim_space(div11_nodes);
			div9 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div9).forEach(detach_dev);
			t14 = claim_space(div11_nodes);
			div10 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div10).forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			t15 = claim_space(div20_nodes);
			div15 = claim_element(div20_nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			h33 = claim_element(div15_nodes, "H3", { class: true });
			var h33_nodes = children(h33);
			t16 = claim_text(h33_nodes, t16_value);
			h33_nodes.forEach(detach_dev);
			t17 = claim_space(div15_nodes);
			div12 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div12).forEach(detach_dev);
			t18 = claim_space(div15_nodes);
			div13 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div13).forEach(detach_dev);
			t19 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div14).forEach(detach_dev);
			div15_nodes.forEach(detach_dev);
			t20 = claim_space(div20_nodes);
			div19 = claim_element(div20_nodes, "DIV", { class: true });
			var div19_nodes = children(div19);
			h34 = claim_element(div19_nodes, "H3", { class: true });
			var h34_nodes = children(h34);
			t21 = claim_text(h34_nodes, t21_value);
			h34_nodes.forEach(detach_dev);
			t22 = claim_space(div19_nodes);
			div16 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div16).forEach(detach_dev);
			t23 = claim_space(div19_nodes);
			div17 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div17).forEach(detach_dev);
			t24 = claim_space(div19_nodes);
			div18 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div18).forEach(detach_dev);
			div19_nodes.forEach(detach_dev);
			div20_nodes.forEach(detach_dev);
			t25 = claim_space(div29_nodes);
			div28 = claim_element(div29_nodes, "DIV", { class: true });
			var div28_nodes = children(div28);
			div25 = claim_element(div28_nodes, "DIV", { class: true });
			var div25_nodes = children(div25);
			div21 = claim_element(div25_nodes, "DIV", { class: true });
			var div21_nodes = children(div21);
			t26 = claim_text(div21_nodes, "total correct: ");
			t27 = claim_text(div21_nodes, t27_value);
			div21_nodes.forEach(detach_dev);
			t28 = claim_space(div25_nodes);
			div22 = claim_element(div25_nodes, "DIV", { class: true });
			var div22_nodes = children(div22);
			t29 = claim_text(div22_nodes, "total wrong: ");
			t30 = claim_text(div22_nodes, t30_value);
			div22_nodes.forEach(detach_dev);
			t31 = claim_space(div25_nodes);
			div23 = claim_element(div25_nodes, "DIV", { class: true });
			var div23_nodes = children(div23);
			t32 = claim_text(div23_nodes, "round ");
			t33 = claim_text(div23_nodes, /*round*/ ctx[0]);
			t34 = claim_text(div23_nodes, " correct: ");
			t35 = claim_text(div23_nodes, t35_value);
			div23_nodes.forEach(detach_dev);
			t36 = claim_space(div25_nodes);
			div24 = claim_element(div25_nodes, "DIV", { class: true });
			var div24_nodes = children(div24);
			t37 = claim_text(div24_nodes, "round ");
			t38 = claim_text(div24_nodes, /*round*/ ctx[0]);
			t39 = claim_text(div24_nodes, " wrong: ");
			t40 = claim_text(div24_nodes, t40_value);
			div24_nodes.forEach(detach_dev);
			div25_nodes.forEach(detach_dev);
			t41 = claim_space(div28_nodes);
			div26 = claim_element(div28_nodes, "DIV", { class: true });
			var div26_nodes = children(div26);
			t42 = claim_text(div26_nodes, "Round ");
			t43 = claim_text(div26_nodes, /*round*/ ctx[0]);
			div26_nodes.forEach(detach_dev);
			t44 = claim_space(div28_nodes);
			div27 = claim_element(div28_nodes, "DIV", { class: true, id: true });
			var div27_nodes = children(div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div27_nodes);
			}

			div27_nodes.forEach(detach_dev);
			div28_nodes.forEach(detach_dev);
			div29_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h30, "class", "colHeading svelte-ctpe5c");
			add_location(h30, file, 321, 3, 9227);
			attr_dev(div0, "id", "t1");
			attr_dev(div0, "class", "target col1 svelte-ctpe5c");
			add_location(div0, file, 322, 3, 9284);
			attr_dev(div1, "id", "t2");
			attr_dev(div1, "class", "target col1 svelte-ctpe5c");
			add_location(div1, file, 323, 3, 9366);
			attr_dev(div2, "id", "t3");
			attr_dev(div2, "class", "target col1 svelte-ctpe5c");
			add_location(div2, file, 324, 3, 9448);
			attr_dev(div3, "class", "column c1 svelte-ctpe5c");
			add_location(div3, file, 320, 2, 9200);
			attr_dev(h31, "class", "colHeading svelte-ctpe5c");
			add_location(h31, file, 327, 3, 9565);
			attr_dev(div4, "id", "t4");
			attr_dev(div4, "class", "target col2 svelte-ctpe5c");
			add_location(div4, file, 328, 3, 9622);
			attr_dev(div5, "id", "t5");
			attr_dev(div5, "class", "target col2 svelte-ctpe5c");
			add_location(div5, file, 329, 3, 9704);
			attr_dev(div6, "id", "t6");
			attr_dev(div6, "class", "target col2 svelte-ctpe5c");
			add_location(div6, file, 330, 3, 9786);
			attr_dev(div7, "class", "column c2 svelte-ctpe5c");
			add_location(div7, file, 326, 2, 9538);
			attr_dev(h32, "class", "colHeading svelte-ctpe5c");
			add_location(h32, file, 333, 3, 9903);
			attr_dev(div8, "id", "t7");
			attr_dev(div8, "class", "target col3 svelte-ctpe5c");
			add_location(div8, file, 334, 3, 9960);
			attr_dev(div9, "id", "t8");
			attr_dev(div9, "class", "target col3 svelte-ctpe5c");
			add_location(div9, file, 335, 3, 10042);
			attr_dev(div10, "id", "t9");
			attr_dev(div10, "class", "target col3 svelte-ctpe5c");
			add_location(div10, file, 336, 3, 10124);
			attr_dev(div11, "class", "column c3 svelte-ctpe5c");
			add_location(div11, file, 332, 2, 9876);
			attr_dev(h33, "class", "colHeading svelte-ctpe5c");
			add_location(h33, file, 339, 3, 10241);
			attr_dev(div12, "id", "t10");
			attr_dev(div12, "class", "target col4 svelte-ctpe5c");
			add_location(div12, file, 340, 3, 10298);
			attr_dev(div13, "id", "t11");
			attr_dev(div13, "class", "target col4 svelte-ctpe5c");
			add_location(div13, file, 341, 3, 10381);
			attr_dev(div14, "id", "t12");
			attr_dev(div14, "class", "target col4 svelte-ctpe5c");
			add_location(div14, file, 342, 3, 10464);
			attr_dev(div15, "class", "column c4 svelte-ctpe5c");
			add_location(div15, file, 338, 2, 10214);
			attr_dev(h34, "class", "colHeading svelte-ctpe5c");
			add_location(h34, file, 345, 3, 10582);
			attr_dev(div16, "id", "t13");
			attr_dev(div16, "class", "target col5 svelte-ctpe5c");
			add_location(div16, file, 346, 3, 10639);
			attr_dev(div17, "id", "t14");
			attr_dev(div17, "class", "target col5 svelte-ctpe5c");
			add_location(div17, file, 347, 3, 10722);
			attr_dev(div18, "id", "t15");
			attr_dev(div18, "class", "target col5 svelte-ctpe5c");
			add_location(div18, file, 348, 3, 10805);
			attr_dev(div19, "class", "column c5 svelte-ctpe5c");
			add_location(div19, file, 344, 2, 10555);
			attr_dev(div20, "class", "target-container svelte-ctpe5c");
			add_location(div20, file, 319, 1, 9167);
			attr_dev(div21, "class", "score-item svelte-ctpe5c");
			add_location(div21, file, 354, 3, 10990);
			attr_dev(div22, "class", "score-item svelte-ctpe5c");
			add_location(div22, file, 355, 3, 11064);
			attr_dev(div23, "class", "score-item svelte-ctpe5c");
			add_location(div23, file, 356, 3, 11134);
			attr_dev(div24, "class", "score-item svelte-ctpe5c");
			add_location(div24, file, 357, 3, 11258);
			attr_dev(div25, "class", "score-container svelte-ctpe5c");
			add_location(div25, file, 353, 2, 10929);
			attr_dev(div26, "class", "round-label svelte-ctpe5c");
			add_location(div26, file, 360, 2, 11385);
			attr_dev(div27, "class", "pieces-container svelte-ctpe5c");
			attr_dev(div27, "id", div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2");
			add_location(div27, file, 362, 2, 11461);
			attr_dev(div28, "class", "game-bar svelte-ctpe5c");
			add_location(div28, file, 352, 1, 10904);
			attr_dev(div29, "class", "game-page svelte-ctpe5c");
			add_location(div29, file, 318, 0, 9099);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div29, anchor);
			append_dev(div29, div20);
			append_dev(div20, div3);
			append_dev(div3, h30);
			append_dev(h30, t1);
			append_dev(div3, t2);
			append_dev(div3, div0);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div20, t5);
			append_dev(div20, div7);
			append_dev(div7, h31);
			append_dev(h31, t6);
			append_dev(div7, t7);
			append_dev(div7, div4);
			append_dev(div7, t8);
			append_dev(div7, div5);
			append_dev(div7, t9);
			append_dev(div7, div6);
			append_dev(div20, t10);
			append_dev(div20, div11);
			append_dev(div11, h32);
			append_dev(h32, t11);
			append_dev(div11, t12);
			append_dev(div11, div8);
			append_dev(div11, t13);
			append_dev(div11, div9);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div20, t15);
			append_dev(div20, div15);
			append_dev(div15, h33);
			append_dev(h33, t16);
			append_dev(div15, t17);
			append_dev(div15, div12);
			append_dev(div15, t18);
			append_dev(div15, div13);
			append_dev(div15, t19);
			append_dev(div15, div14);
			append_dev(div20, t20);
			append_dev(div20, div19);
			append_dev(div19, h34);
			append_dev(h34, t21);
			append_dev(div19, t22);
			append_dev(div19, div16);
			append_dev(div19, t23);
			append_dev(div19, div17);
			append_dev(div19, t24);
			append_dev(div19, div18);
			append_dev(div29, t25);
			append_dev(div29, div28);
			append_dev(div28, div25);
			append_dev(div25, div21);
			append_dev(div21, t26);
			append_dev(div21, t27);
			append_dev(div25, t28);
			append_dev(div25, div22);
			append_dev(div22, t29);
			append_dev(div22, t30);
			append_dev(div25, t31);
			append_dev(div25, div23);
			append_dev(div23, t32);
			append_dev(div23, t33);
			append_dev(div23, t34);
			append_dev(div23, t35);
			append_dev(div25, t36);
			append_dev(div25, div24);
			append_dev(div24, t37);
			append_dev(div24, t38);
			append_dev(div24, t39);
			append_dev(div24, t40);
			append_dev(div28, t41);
			append_dev(div28, div26);
			append_dev(div26, t42);
			append_dev(div26, t43);
			append_dev(div28, t44);
			append_dev(div28, div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div27, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div0, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div1, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div1, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div2, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div2, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div4, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div4, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div5, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div5, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div6, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div6, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div8, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div8, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div9, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div9, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div10, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div10, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div12, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div12, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div13, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div13, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div14, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div14, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div16, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div16, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div17, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div17, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div18, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div18, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div27, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div27, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div29, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div29, "dragover", /*allowDrop*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 4) && title_value !== (title_value = /*title*/ ctx[2])) {
				document_1.title = title_value;
			}

			if ((!current || dirty & /*colHeadings*/ 2) && t1_value !== (t1_value = /*colHeadings*/ ctx[1].col1Heading + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t6_value !== (t6_value = /*colHeadings*/ ctx[1].col2Heading + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t11_value !== (t11_value = /*colHeadings*/ ctx[1].col3Heading + "")) set_data_dev(t11, t11_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t16_value !== (t16_value = /*colHeadings*/ ctx[1].col4Heading + "")) set_data_dev(t16, t16_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t21_value !== (t21_value = /*colHeadings*/ ctx[1].col5Heading + "")) set_data_dev(t21, t21_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t27_value !== (t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "")) set_data_dev(t27, t27_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t30_value !== (t30_value = /*$dnd_store*/ ctx[5].totalWrong + "")) set_data_dev(t30, t30_value);
			if (!current || dirty & /*round*/ 1) set_data_dev(t33, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t35_value !== (t35_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Correct
			: /*$dnd_store*/ ctx[5].round2Correct) + "")) set_data_dev(t35, t35_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t38, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t40_value !== (t40_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Wrong
			: /*$dnd_store*/ ctx[5].round2Wrong) + "")) set_data_dev(t40, t40_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t43, /*round*/ ctx[0]);

			if (dirty & /*piecesArray, dragItem, handleDrag*/ 592) {
				each_value = /*piecesArray*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div27, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*round*/ 1 && div27_id_value !== (div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2")) {
				attr_dev(div27, "id", div27_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (div25_outro) div25_outro.end(1);
			if (div26_outro) div26_outro.end(1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			div25_outro = create_out_transition(div25, fade, { duration: 10 });
			div26_outro = create_out_transition(div26, fade, { duration: 10 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div29);
			if (detaching && div25_outro) div25_outro.end();
			if (detaching && div26_outro) div26_outro.end();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $dnd_store,
		$$unsubscribe_dnd_store = noop,
		$$subscribe_dnd_store = () => ($$unsubscribe_dnd_store(), $$unsubscribe_dnd_store = subscribe(dnd_store, $$value => $$invalidate(5, $dnd_store = $$value)), dnd_store);

	$$self.$$.on_destroy.push(() => $$unsubscribe_dnd_store());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameBoard", slots, []);
	let { colHeadings } = $$props;
	let { pieces } = $$props;
	let { round } = $$props;
	let { title } = $$props;
	let { dnd_store } = $$props;
	validate_store(dnd_store, "dnd_store");
	$$subscribe_dnd_store();
	let piecesArray = [];
	let piecesLeft = 30;
	const dispatch = createEventDispatcher();

	onMount(() => {
		$$invalidate(4, piecesArray = [...pieces]);
		$$invalidate(4, piecesArray = shuffleArray(piecesArray));

		// firstLoad starts as true, and is immediately turned false
		// this will affect score reset onMount so that round 2 is not reset
		// but reset will happen when coming back after game is over
		dnd_store.changeFirstLoad(false);
	});

	const shuffleArray = array => {
		// copy array to manipulate
		let arrayCopy = [...array];

		let mixedArray = [];

		// loop through copy until no elements left
		while (arrayCopy.length > 0) {
			let randNum = Math.floor(Math.random() * arrayCopy.length);

			// add removed elements to mixedArray as looping occurs
			mixedArray.push(arrayCopy.splice(randNum, 1)[0]);
		}

		return mixedArray;
	};

	const dragItem = e => {
		if (e.target.tagName === "IMG") {
			e.dataTransfer.setData("text", e.target.parentNode.id);
		} else {
			e.dataTransfer.setData("text", e.target.id);
		}
	};

	const dropItem = e => {
		// define pieces container to allow drop of item back into original spot
		let isPiecesContainer = hasClass(e.target, "pieces-container");

		// let parent = e.target.parentNode;
		let dragItemId = e.dataTransfer.getData("text");

		let dragItem = document.getElementById(dragItemId);

		// if target to drop in is empty or the target is the pices container, you can drop item in
		if (!e.target.firstChild || isPiecesContainer) {
			// if the target is not the pieces container
			if (!isPiecesContainer) {
				// setting to static position so the div will be relative to parent
				dragItem.style.position = "static";

				// must make visible again because I am hadding all stacked pieces in
				// the pieces container to display only the top piece so as to not
				// stack box-shadows
				dragItem.style.visibility = "visible";

				//
				if (// check if parent has the odd numbered classes to adjust font color
				hasClass(e.target, "col1") || hasClass(e.target, "col3") || hasClass(e.target, "col5")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#0d223f"; // navy blue
					dragItem.style.color = "#77bc43";
				} else if (hasClass(e.target, "col2") || hasClass(e.target, "col4")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#77bc43"; // green
					dragItem.style.color = "#0d223f";
				}

				if (!checkIsMatch(e.target, dragItem)) {
					dnd_store.incWrongCount(round);
					e.target.style.backgroundColor = "#bf1d1d"; // bg = red
					dragItem.style.color = "#e8e1e1"; // font color = light gray
				} else if (checkIsMatch(e.target, dragItem)) {
					dnd_store.incCorrectCount(round);

					if (dragItem.children.length >= 1) {
						if (dragItem.children[0].tagName === "IMG") {
							dragItem.children[0].setAttribute("draggable", "false");

							// typecast because property does not exist on type 'element'
							dragItem.children[0].style.cursor = "no-drop";

							dragItem.style.maxHeight = "110px";
						}
					} else {
						dragItem.style.overflow = "auto";
					}

					dragItem.setAttribute("draggable", "false");
					dragItem.style.border = "none";
					dragItem.style.userSelect = "none";
					dragItem.style.boxShadow = "none";
					dragItem.style.cursor = "no-drop";
				}
			} else if (isPiecesContainer) {
				// if being placed back in the pieces container, going back to absolute and resetting bkgrnd & font color
				dragItem.style.position = "absolute";

				dragItem.style.backgroundColor = "rgb(115, 167, 167)";
				dragItem.style.color = "rgb(15, 21, 21)";
			}

			// now the actual placement occurs
			e.preventDefault();

			e.target.appendChild(dragItem);

			let piecesCont = round === 1
			? document.getElementById("piecesCont1")
			: document.getElementById("piecesCont2");

			$$invalidate(11, piecesLeft = checkPiecesLeft(piecesCont));
		}
	};

	const allowDrop = e => {
		e.preventDefault();
	};

	const handleDrag = e => {
		e.target.style.cursor = "grabbing";
	};

	const checkIsMatch = (target, dragItem) => {
		if (hasClass(target, "col1") && hasClass(dragItem, "col1")) {
			return true;
		} else if (hasClass(target, "col2") && hasClass(dragItem, "col2")) {
			return true;
		} else if (hasClass(target, "col3") && hasClass(dragItem, "col3")) {
			return true;
		} else if (hasClass(target, "col4") && hasClass(dragItem, "col4")) {
			return true;
		} else if (hasClass(target, "col5") && hasClass(dragItem, "col5")) {
			return true;
		} else {
			return false;
		}
	};

	const hasClass = (el, clss) => {
		return el.classList.contains(clss);
	};

	const checkPiecesLeft = el => {
		const numChildNodes = el.childNodes.length;
		return numChildNodes;
	};

	const writable_props = ["colHeadings", "pieces", "round", "title", "dnd_store"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GameBoard> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
	};

	$$self.$capture_state = () => ({
		onMount,
		createEventDispatcher,
		fade,
		colHeadings,
		pieces,
		round,
		title,
		dnd_store,
		piecesArray,
		piecesLeft,
		dispatch,
		shuffleArray,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		checkIsMatch,
		hasClass,
		checkPiecesLeft,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
		if ("piecesArray" in $$props) $$invalidate(4, piecesArray = $$props.piecesArray);
		if ("piecesLeft" in $$props) $$invalidate(11, piecesLeft = $$props.piecesLeft);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*piecesLeft, round*/ 2049) {
			 if (piecesLeft <= 15) {
				// if current round is 1, then change to 2, else change to 3
				$$invalidate(0, round = round === 1 ? 2 : 3);

				dispatch("checkround", round);
			}
		}

		if ($$self.$$.dirty & /*$dnd_store, round, dnd_store*/ 41) {
			 {
				if (!$dnd_store.firstLoad && round === 1) {
					// reset only if game has been loaded and user is back to round 1
					dnd_store.resetScores();
				}
			}
		}
	};

	return [
		round,
		colHeadings,
		title,
		dnd_store,
		piecesArray,
		$dnd_store,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		pieces
	];
}

class GameBoard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			colHeadings: 1,
			pieces: 10,
			round: 0,
			title: 2,
			dnd_store: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameBoard",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*colHeadings*/ ctx[1] === undefined && !("colHeadings" in props)) {
			console.warn("<GameBoard> was created without expected prop 'colHeadings'");
		}

		if (/*pieces*/ ctx[10] === undefined && !("pieces" in props)) {
			console.warn("<GameBoard> was created without expected prop 'pieces'");
		}

		if (/*round*/ ctx[0] === undefined && !("round" in props)) {
			console.warn("<GameBoard> was created without expected prop 'round'");
		}

		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
			console.warn("<GameBoard> was created without expected prop 'title'");
		}

		if (/*dnd_store*/ ctx[3] === undefined && !("dnd_store" in props)) {
			console.warn("<GameBoard> was created without expected prop 'dnd_store'");
		}
	}

	get colHeadings() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colHeadings(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pieces() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pieces(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dnd_store() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_store(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/GameOver.svelte generated by Svelte v3.29.0 */

const file$1 = "src/components/GameOver.svelte";

function create_fragment$1(ctx) {
	let div;
	let h1;
	let t0;
	let t1;
	let h40;
	let t2;
	let t3;
	let t4;
	let h41;
	let t5;
	let t6;
	let t7;
	let h42;
	let t8;
	let t9;

	const block = {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Game Over");
			t1 = space();
			h40 = element("h4");
			t2 = text("Total Correct: ");
			t3 = text(/*totalCorrect*/ ctx[0]);
			t4 = space();
			h41 = element("h4");
			t5 = text("Total Wrong: ");
			t6 = text(/*totalWrong*/ ctx[1]);
			t7 = space();
			h42 = element("h4");
			t8 = text("Final Score: ");
			t9 = text(/*finalScore*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Game Over");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			h40 = claim_element(div_nodes, "H4", { class: true });
			var h40_nodes = children(h40);
			t2 = claim_text(h40_nodes, "Total Correct: ");
			t3 = claim_text(h40_nodes, /*totalCorrect*/ ctx[0]);
			h40_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			h41 = claim_element(div_nodes, "H4", { class: true });
			var h41_nodes = children(h41);
			t5 = claim_text(h41_nodes, "Total Wrong: ");
			t6 = claim_text(h41_nodes, /*totalWrong*/ ctx[1]);
			h41_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			h42 = claim_element(div_nodes, "H4", { class: true });
			var h42_nodes = children(h42);
			t8 = claim_text(h42_nodes, "Final Score: ");
			t9 = claim_text(h42_nodes, /*finalScore*/ ctx[2]);
			h42_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "title svelte-1g63pp");
			add_location(h1, file$1, 29, 1, 518);
			attr_dev(h40, "class", "score-content svelte-1g63pp");
			add_location(h40, file$1, 30, 1, 552);
			attr_dev(h41, "class", "score-content svelte-1g63pp");
			add_location(h41, file$1, 31, 1, 614);
			attr_dev(h42, "class", "score-content svelte-1g63pp");
			add_location(h42, file$1, 32, 1, 672);
			attr_dev(div, "class", "game-over_container svelte-1g63pp");
			add_location(div, file$1, 28, 0, 483);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t0);
			append_dev(div, t1);
			append_dev(div, h40);
			append_dev(h40, t2);
			append_dev(h40, t3);
			append_dev(div, t4);
			append_dev(div, h41);
			append_dev(h41, t5);
			append_dev(h41, t6);
			append_dev(div, t7);
			append_dev(div, h42);
			append_dev(h42, t8);
			append_dev(h42, t9);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*totalCorrect*/ 1) set_data_dev(t3, /*totalCorrect*/ ctx[0]);
			if (dirty & /*totalWrong*/ 2) set_data_dev(t6, /*totalWrong*/ ctx[1]);
			if (dirty & /*finalScore*/ 4) set_data_dev(t9, /*finalScore*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameOver", slots, []);
	let { totalCorrect } = $$props;
	let { totalWrong } = $$props;
	let finalScore;
	const writable_props = ["totalCorrect", "totalWrong"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GameOver> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
	};

	$$self.$capture_state = () => ({ totalCorrect, totalWrong, finalScore });

	$$self.$inject_state = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
		if ("finalScore" in $$props) $$invalidate(2, finalScore = $$props.finalScore);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*totalWrong*/ 2) {
			 {
				let calcScore = Math.round((30 - totalWrong) / 30 * 100);
				$$invalidate(2, finalScore = calcScore >= 0 ? calcScore : 0);
			}
		}
	};

	return [totalCorrect, totalWrong, finalScore];
}

class GameOver extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { totalCorrect: 0, totalWrong: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameOver",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*totalCorrect*/ ctx[0] === undefined && !("totalCorrect" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalCorrect'");
		}

		if (/*totalWrong*/ ctx[1] === undefined && !("totalWrong" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalWrong'");
		}
	}

	get totalCorrect() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalCorrect(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get totalWrong() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalWrong(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/DnD.svelte generated by Svelte v3.29.0 */
const file$2 = "src/components/DnD.svelte";

// (26:29) 
function create_if_block_2(ctx) {
	let div;
	let gameover;
	let div_intro;
	let current;

	gameover = new GameOver({
			props: {
				totalCorrect: /*$dnd_store*/ ctx[5].totalCorrect,
				totalWrong: /*$dnd_store*/ ctx[5].totalWrong
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameover.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameover.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 26, 1, 1133);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameover, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameover_changes = {};
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalCorrect = /*$dnd_store*/ ctx[5].totalCorrect;
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalWrong = /*$dnd_store*/ ctx[5].totalWrong;
			gameover.$set(gameover_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameover.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { y: 200, delay: 600 });
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(gameover.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameover);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(26:29) ",
		ctx
	});

	return block;
}

// (22:29) 
function create_if_block_1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 22, 1, 899);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { delay: 600, duration: 500 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fly, { x: 200, duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(22:29) ",
		ctx
	});

	return block;
}

// (18:0) {#if updatedRound === 1}
function create_if_block$1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 18, 1, 684);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { duration: 300 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fade, { duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(18:0) {#if updatedRound === 1}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*updatedRound*/ ctx[1] === 1) return 0;
		if (/*updatedRound*/ ctx[1] === 2) return 1;
		if (/*updatedRound*/ ctx[1] === 3) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $dnd_store;
	validate_store(dnd_store, "dnd_store");
	component_subscribe($$self, dnd_store, $$value => $$invalidate(5, $dnd_store = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DnD", slots, []);
	let { dnd_content } = $$props;

	// TS/Svelte requires this pattern for reactive declarations (https://blog.scottlogic.com/2020/07/24/svelte-ts.html)
	let updatedRound;

	let colHeadings;

	const updateRound = e => {
		$$invalidate(1, updatedRound = e.detail);
	};

	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DnD> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({
		dnd_store,
		GameBoard,
		fade,
		fly,
		GameOver,
		dnd_content,
		updatedRound,
		colHeadings,
		updateRound,
		pieces,
		round,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
		if ("updatedRound" in $$props) $$invalidate(1, updatedRound = $$props.updatedRound);
		if ("colHeadings" in $$props) $$invalidate(2, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(3, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(4, round = $$props.round);
	};

	let pieces;
	let round;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(2, colHeadings = updatedRound === 1
			? dnd_content.dndgame1
			: dnd_content.dndgame2);
		}

		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(3, pieces = updatedRound === 1
			? dnd_content.pieces1
			: dnd_content.pieces2);
		}

		if ($$self.$$.dirty & /*updatedRound*/ 2) {
			 $$invalidate(4, round = updatedRound);
		}
	};

	 $$invalidate(1, updatedRound = 1);
	return [dnd_content, updatedRound, colHeadings, pieces, round, $dnd_store, updateRound];
}

class DnD extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DnD",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<DnD> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<DnD>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<DnD>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/dndgame/[dnd_unit].svelte generated by Svelte v3.29.0 */

function create_fragment$3(ctx) {
	let title_value;
	let t;
	let dnd;
	let current;
	document.title = title_value = /*dnd_content*/ ctx[0].title;

	dnd = new DnD({
			props: { dnd_content: /*dnd_content*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t = space();
			create_component(dnd.$$.fragment);
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-8wlx8a\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(dnd.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			mount_component(dnd, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*dnd_content*/ 1) && title_value !== (title_value = /*dnd_content*/ ctx[0].title)) {
				document.title = title_value;
			}

			const dnd_changes = {};
			if (dirty & /*dnd_content*/ 1) dnd_changes.dnd_content = /*dnd_content*/ ctx[0];
			dnd.$set(dnd_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dnd.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dnd.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			destroy_component(dnd, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload(page, session) {
	const { dnd_unit } = page.params;
	const res = await this.fetch(`data/${dnd_unit}.json`);
	const dnd_content = await res.json();
	return { dnd_content };
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("U5Bdnd_unitu5D", slots, []);
	let { dnd_content } = $$props; // this gets defined in script module above
	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bdnd_unitu5D> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({ preload, DnD, dnd_content });

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dnd_content];
}

class U5Bdnd_unitu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bdnd_unitu5D",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<U5Bdnd_unitu5D> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bdnd_unitu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2RuZF91bml0XS4xNTI4NDY0Ni5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3Jlcy9kbmRfZ2FtZV9zdG9yZS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0dhbWVCb2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9HYW1lT3Zlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9EbkQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kbmRnYW1lL1tkbmRfdW5pdF0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBkbmRfc3RvcmVfZGF0YSA9IHdyaXRhYmxlKHtcblx0dG90YWxDb3JyZWN0OiAwLFxuXHR0b3RhbFdyb25nOiAwLFxuXHRyb3VuZDFDb3JyZWN0OiAwLFxuXHRyb3VuZDFXcm9uZzogMCxcblx0cm91bmQyQ29ycmVjdDogMCxcblx0cm91bmQyV3Jvbmc6IDAsXG5cdGZpcnN0TG9hZDogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZG5kX3N0b3JlID0ge1xuXHRzdWJzY3JpYmU6IGRuZF9zdG9yZV9kYXRhLnN1YnNjcmliZSxcblx0aW5jQ29ycmVjdENvdW50OiAocm91bmQpID0+IHtcblx0XHRkbmRfc3RvcmVfZGF0YS51cGRhdGUoKGRhdGEpID0+IHtcblx0XHRcdGlmIChyb3VuZCA9PT0gMSkge1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0XHQuLi5kYXRhLFxuXHRcdFx0XHRcdHJvdW5kMUNvcnJlY3Q6IGRhdGEucm91bmQxQ29ycmVjdCArIDEsXG5cdFx0XHRcdFx0dG90YWxDb3JyZWN0OiBkYXRhLnRvdGFsQ29ycmVjdCArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJDb3JyZWN0OiBkYXRhLnJvdW5kMkNvcnJlY3QgKyAxLFxuXHRcdFx0XHRcdHRvdGFsQ29ycmVjdDogZGF0YS50b3RhbENvcnJlY3QgKyAxLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlZERhdGE7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGluY1dyb25nQ291bnQ6IChyb3VuZCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnVwZGF0ZSgoZGF0YSkgPT4ge1xuXHRcdFx0aWYgKHJvdW5kID09PSAxKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuXHRcdFx0XHRcdC4uLmRhdGEsXG5cdFx0XHRcdFx0cm91bmQxV3Jvbmc6IGRhdGEucm91bmQxV3JvbmcgKyAxLFxuXHRcdFx0XHRcdHRvdGFsV3Jvbmc6IGRhdGEudG90YWxXcm9uZyArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJXcm9uZzogZGF0YS5yb3VuZDJXcm9uZyArIDEsXG5cdFx0XHRcdFx0dG90YWxXcm9uZzogZGF0YS50b3RhbFdyb25nICsgMSxcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZWREYXRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRyZXNldFNjb3JlczogKCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnNldCh7XG5cdFx0XHR0b3RhbENvcnJlY3Q6IDAsXG5cdFx0XHR0b3RhbFdyb25nOiAwLFxuXHRcdFx0cm91bmQxQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMVdyb25nOiAwLFxuXHRcdFx0cm91bmQyQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMldyb25nOiAwLFxuXHRcdFx0Zmlyc3RMb2FkOiB0cnVlLFxuXHRcdH0pO1xuXHR9LFxuXHRjaGFuZ2VGaXJzdExvYWQ6IChuZXdCb29sKSA9PiB7XG5cdFx0ZG5kX3N0b3JlX2RhdGEudXBkYXRlKChkYXRhKSA9PiB7XG5cdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0Zmlyc3RMb2FkOiBuZXdCb29sLFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHR9KTtcblx0fSxcbn07XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0ZXhwb3J0IGxldCBjb2xIZWFkaW5ncztcblx0ZXhwb3J0IGxldCBwaWVjZXM7XG5cdGV4cG9ydCBsZXQgcm91bmQ7XG5cdGV4cG9ydCBsZXQgdGl0bGU7XG5cdGV4cG9ydCBsZXQgZG5kX3N0b3JlO1xuXHRsZXQgcGllY2VzQXJyYXkgPSBbXTtcblx0bGV0IHBpZWNlc0xlZnQgPSAzMDtcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0JDogaWYgKHBpZWNlc0xlZnQgPD0gMTUpIHtcblx0XHQvLyBpZiBjdXJyZW50IHJvdW5kIGlzIDEsIHRoZW4gY2hhbmdlIHRvIDIsIGVsc2UgY2hhbmdlIHRvIDNcblx0XHRyb3VuZCA9IHJvdW5kID09PSAxID8gMiA6IDM7XG5cdFx0ZGlzcGF0Y2goXCJjaGVja3JvdW5kXCIsIHJvdW5kKTtcblx0fVxuXHQkOiB7XG5cdFx0aWYgKCEkZG5kX3N0b3JlLmZpcnN0TG9hZCAmJiByb3VuZCA9PT0gMSkge1xuXHRcdFx0Ly8gcmVzZXQgb25seSBpZiBnYW1lIGhhcyBiZWVuIGxvYWRlZCBhbmQgdXNlciBpcyBiYWNrIHRvIHJvdW5kIDFcblx0XHRcdGRuZF9zdG9yZS5yZXNldFNjb3JlcygpO1xuXHRcdH1cblx0fVxuXHRvbk1vdW50KCgpID0+IHtcblx0XHRwaWVjZXNBcnJheSA9IFsuLi5waWVjZXNdO1xuXHRcdHBpZWNlc0FycmF5ID0gc2h1ZmZsZUFycmF5KHBpZWNlc0FycmF5KTtcblx0XHQvLyBmaXJzdExvYWQgc3RhcnRzIGFzIHRydWUsIGFuZCBpcyBpbW1lZGlhdGVseSB0dXJuZWQgZmFsc2Vcblx0XHQvLyB0aGlzIHdpbGwgYWZmZWN0IHNjb3JlIHJlc2V0IG9uTW91bnQgc28gdGhhdCByb3VuZCAyIGlzIG5vdCByZXNldFxuXHRcdC8vIGJ1dCByZXNldCB3aWxsIGhhcHBlbiB3aGVuIGNvbWluZyBiYWNrIGFmdGVyIGdhbWUgaXMgb3ZlclxuXHRcdGRuZF9zdG9yZS5jaGFuZ2VGaXJzdExvYWQoZmFsc2UpO1xuXHR9KTtcblx0Y29uc3Qgc2h1ZmZsZUFycmF5ID0gKGFycmF5KSA9PiB7XG5cdFx0Ly8gY29weSBhcnJheSB0byBtYW5pcHVsYXRlXG5cdFx0bGV0IGFycmF5Q29weSA9IFsuLi5hcnJheV07XG5cdFx0bGV0IG1peGVkQXJyYXkgPSBbXTtcblx0XHQvLyBsb29wIHRocm91Z2ggY29weSB1bnRpbCBubyBlbGVtZW50cyBsZWZ0XG5cdFx0d2hpbGUgKGFycmF5Q29weS5sZW5ndGggPiAwKSB7XG5cdFx0XHRsZXQgcmFuZE51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Q29weS5sZW5ndGgpO1xuXHRcdFx0Ly8gYWRkIHJlbW92ZWQgZWxlbWVudHMgdG8gbWl4ZWRBcnJheSBhcyBsb29waW5nIG9jY3Vyc1xuXHRcdFx0bWl4ZWRBcnJheS5wdXNoKGFycmF5Q29weS5zcGxpY2UocmFuZE51bSwgMSlbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWl4ZWRBcnJheTtcblx0fTtcblx0Y29uc3QgZHJhZ0l0ZW0gPSAoZSkgPT4ge1xuXHRcdGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIklNR1wiKSB7XG5cdFx0XHRlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBlLnRhcmdldC5wYXJlbnROb2RlLmlkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgZS50YXJnZXQuaWQpO1xuXHRcdH1cblx0fTtcblx0Y29uc3QgZHJvcEl0ZW0gPSAoZSkgPT4ge1xuXHRcdC8vIGRlZmluZSBwaWVjZXMgY29udGFpbmVyIHRvIGFsbG93IGRyb3Agb2YgaXRlbSBiYWNrIGludG8gb3JpZ2luYWwgc3BvdFxuXHRcdGxldCBpc1BpZWNlc0NvbnRhaW5lciA9IGhhc0NsYXNzKGUudGFyZ2V0LCBcInBpZWNlcy1jb250YWluZXJcIik7XG5cdFx0Ly8gbGV0IHBhcmVudCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0bGV0IGRyYWdJdGVtSWQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dFwiKTtcblx0XHRsZXQgZHJhZ0l0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmFnSXRlbUlkKTtcblx0XHQvLyBpZiB0YXJnZXQgdG8gZHJvcCBpbiBpcyBlbXB0eSBvciB0aGUgdGFyZ2V0IGlzIHRoZSBwaWNlcyBjb250YWluZXIsIHlvdSBjYW4gZHJvcCBpdGVtIGluXG5cdFx0aWYgKCFlLnRhcmdldC5maXJzdENoaWxkIHx8IGlzUGllY2VzQ29udGFpbmVyKSB7XG5cdFx0XHQvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCB0aGUgcGllY2VzIGNvbnRhaW5lclxuXHRcdFx0aWYgKCFpc1BpZWNlc0NvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBzZXR0aW5nIHRvIHN0YXRpYyBwb3NpdGlvbiBzbyB0aGUgZGl2IHdpbGwgYmUgcmVsYXRpdmUgdG8gcGFyZW50XG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcblx0XHRcdFx0Ly8gbXVzdCBtYWtlIHZpc2libGUgYWdhaW4gYmVjYXVzZSBJIGFtIGhhZGRpbmcgYWxsIHN0YWNrZWQgcGllY2VzIGluXG5cdFx0XHRcdC8vIHRoZSBwaWVjZXMgY29udGFpbmVyIHRvIGRpc3BsYXkgb25seSB0aGUgdG9wIHBpZWNlIHNvIGFzIHRvIG5vdFxuXHRcdFx0XHQvLyBzdGFjayBib3gtc2hhZG93c1xuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHRoZSBvZGQgbnVtYmVyZWQgY2xhc3NlcyB0byBhZGp1c3QgZm9udCBjb2xvclxuXHRcdFx0XHRcdGhhc0NsYXNzKGUudGFyZ2V0LCBcImNvbDFcIikgfHxcblx0XHRcdFx0XHRoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2wzXCIpIHx8XG5cdFx0XHRcdFx0aGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sNVwiKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0ZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMGQyMjNmXCI7IC8vIG5hdnkgYmx1ZVxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjNzdiYzQzXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sMlwiKSB8fCBoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2w0XCIpKSB7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHRcdFx0XHRcdGUudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzc3YmM0M1wiOyAvLyBncmVlblxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjMGQyMjNmXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjaGVja0lzTWF0Y2goZS50YXJnZXQsIGRyYWdJdGVtKSkge1xuXHRcdFx0XHRcdGRuZF9zdG9yZS5pbmNXcm9uZ0NvdW50KHJvdW5kKTtcblx0XHRcdFx0XHRlLnRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNiZjFkMWRcIjsgLy8gYmcgPSByZWRcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5jb2xvciA9IFwiI2U4ZTFlMVwiOyAvLyBmb250IGNvbG9yID0gbGlnaHQgZ3JheVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNoZWNrSXNNYXRjaChlLnRhcmdldCwgZHJhZ0l0ZW0pKSB7XG5cdFx0XHRcdFx0ZG5kX3N0b3JlLmluY0NvcnJlY3RDb3VudChyb3VuZCk7XG5cdFx0XHRcdFx0aWYgKGRyYWdJdGVtLmNoaWxkcmVuLmxlbmd0aCA+PSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoZHJhZ0l0ZW0uY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gXCJJTUdcIikge1xuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIiwgXCJmYWxzZVwiKTtcblx0XHRcdFx0XHRcdFx0Ly8gdHlwZWNhc3QgYmVjYXVzZSBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCBvbiB0eXBlICdlbGVtZW50J1xuXHRcdFx0XHRcdFx0XHQoZHJhZ0l0ZW0uY2hpbGRyZW5bMF0gYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmN1cnNvciA9IFwibm8tZHJvcFwiO1xuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5tYXhIZWlnaHQgPSBcIjExMHB4XCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRyYWdJdGVtLnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLCBcImZhbHNlXCIpO1xuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmJvcmRlciA9IFwibm9uZVwiO1xuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLnVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5ib3hTaGFkb3cgPSBcIm5vbmVcIjtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5jdXJzb3IgPSBcIm5vLWRyb3BcIjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChpc1BpZWNlc0NvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBpZiBiZWluZyBwbGFjZWQgYmFjayBpbiB0aGUgcGllY2VzIGNvbnRhaW5lciwgZ29pbmcgYmFjayB0byBhYnNvbHV0ZSBhbmQgcmVzZXR0aW5nIGJrZ3JuZCAmIGZvbnQgY29sb3Jcblx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiKDExNSwgMTY3LCAxNjcpXCI7XG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCJyZ2IoMTUsIDIxLCAyMSlcIjtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB0aGUgYWN0dWFsIHBsYWNlbWVudCBvY2N1cnNcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGUudGFyZ2V0LmFwcGVuZENoaWxkKGRyYWdJdGVtKTtcblx0XHRcdGxldCBwaWVjZXNDb250ID0gcm91bmQgPT09IDEgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBpZWNlc0NvbnQxXCIpIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwaWVjZXNDb250MlwiKTtcblx0XHRcdHBpZWNlc0xlZnQgPSBjaGVja1BpZWNlc0xlZnQocGllY2VzQ29udCk7XG5cdFx0fVxuXHR9O1xuXHRjb25zdCBhbGxvd0Ryb3AgPSAoZSkgPT4ge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0fTtcblx0Y29uc3QgaGFuZGxlRHJhZyA9IChlKSA9PiB7XG5cdFx0ZS50YXJnZXQuc3R5bGUuY3Vyc29yID0gXCJncmFiYmluZ1wiO1xuXHR9O1xuXHRjb25zdCBjaGVja0lzTWF0Y2ggPSAodGFyZ2V0LCBkcmFnSXRlbSkgPT4ge1xuXHRcdGlmIChoYXNDbGFzcyh0YXJnZXQsIFwiY29sMVwiKSAmJiBoYXNDbGFzcyhkcmFnSXRlbSwgXCJjb2wxXCIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgXCJjb2wyXCIpICYmIGhhc0NsYXNzKGRyYWdJdGVtLCBcImNvbDJcIikpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBcImNvbDNcIikgJiYgaGFzQ2xhc3MoZHJhZ0l0ZW0sIFwiY29sM1wiKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsIFwiY29sNFwiKSAmJiBoYXNDbGFzcyhkcmFnSXRlbSwgXCJjb2w0XCIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgXCJjb2w1XCIpICYmIGhhc0NsYXNzKGRyYWdJdGVtLCBcImNvbDVcIikpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXHRjb25zdCBoYXNDbGFzcyA9IChlbCwgY2xzcykgPT4ge1xuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xzcyk7XG5cdH07XG5cdGNvbnN0IGNoZWNrUGllY2VzTGVmdCA9IChlbCkgPT4ge1xuXHRcdGNvbnN0IG51bUNoaWxkTm9kZXMgPSBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcblx0XHRyZXR1cm4gbnVtQ2hpbGROb2Rlcztcblx0fTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdEBpbXBvcnQgdXJsKFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1TcGFydGFuOndnaHRAMTAwOzIwMDszMDA7NDAwOzUwMCZkaXNwbGF5PXN3YXBcIik7XG5cdCoge1xuXHRcdGZvbnQtZmFtaWx5OiBcIlNwYXJ0YW5cIiwgc2Fucy1zZXJpZjtcblx0fVxuXHQuZ2FtZS1wYWdlIHtcblx0XHRoZWlnaHQ6IDY1MHB4O1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdG1pbi13aWR0aDogODMwcHg7XG5cdFx0bWF4LXdpZHRoOiAxNTAwcHg7XG5cdFx0bWFyZ2luOiBhdXRvO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblx0LmdhbWUtYmFyIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRtYXJnaW46IDAuNzVyZW07XG5cdH1cblx0LnBpZWNlcy1jb250YWluZXIge1xuXHRcdGhlaWdodDogMTQ1cHg7XG5cdFx0Lyogd2lkdGg6IDI1JTsgKi9cblx0XHR3aWR0aDogMzAwcHg7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuXHRcdGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0fVxuXHQucGllY2VzIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogdG9wO1xuXHRcdGhlaWdodDogMTEwcHg7XG5cdFx0bWF4LXdpZHRoOiA5MCU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0LyogcGFkZGluZy10b3A6IDEwcHg7ICovXG5cdFx0cGFkZGluZzogNSUgNSUgMCA1JTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZDhkOGQ4O1xuXHRcdGNvbG9yOiAjMzE0NTQxO1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjE1cmVtO1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRjdXJzb3I6IGdyYWI7XG5cdFx0Ym94LXNoYWRvdzogMXB4IDJweCAzcHggYmxhY2s7XG5cdFx0dmlzaWJpbGl0eTogaGlkZGVuO1xuXHR9XG5cdC8qIG9ubHkgc2hvdyBmaXJzdCBkaXYgaW4gY29udGFpbmVyIGhlbHBzIHByZXZlbnRcbiAgc3RhY2tpbmcgdXAgb2YgYm94LXNoYWRvd1xuICBOT1RFOiBtYWtlIHN1cmUgdG8gaGF2ZSBhbnkgZHJvcHBlZCBkaXZzIGluIHRhcmdldHMgdmlzaWJsZSAqL1xuXHQucGllY2VzLWNvbnRhaW5lciBkaXY6Zmlyc3Qtb2YtdHlwZSB7XG5cdFx0dmlzaWJpbGl0eTogdmlzaWJsZTtcblx0fVxuXHQucGllY2VzOjotd2Via2l0LXNjcm9sbGJhciB7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXHQucGllY2VzLnRleHQge1xuXHRcdG92ZXJmbG93OiBhdXRvO1xuXHR9XG5cdC5pbWctY29udGFpbmVyIHtcblx0XHRtYXgtaGVpZ2h0OiAxMzBweDtcblx0XHRwYWRkaW5nOiAxcHg7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRib3gtc2hhZG93OiAxcHggMnB4IDNweCBibGFjaztcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHR9XG5cdC5pbWctcGllY2Uge1xuXHRcdC8qIG1heC1oZWlnaHQ6IDEyMHB4OyAqL1xuXHRcdG1heC1oZWlnaHQ6IDkwJTtcblx0XHQvKiBoZWlnaHQ6IGF1dG87ICovXG5cdFx0LyogbWF4LXdpZHRoOiAxMDAlOyAqL1xuXHRcdG1pbi13aWR0aDogNzVweDtcblx0XHRtYXgtd2lkdGg6IDEwMCU7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRtYXJnaW46IDAgNXB4O1xuXHRcdC8qIHdpZHRoOiA5MCU7ICovXG5cdH1cblx0LnNjb3JlLWNvbnRhaW5lciB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcblx0fVxuXHQuc2NvcmUtaXRlbSB7XG5cdFx0bWFyZ2luLWJvdHRvbTogMC42cmVtO1xuXHR9XG5cdC5yb3VuZC1sYWJlbCB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGhlaWdodDogMTE0cHg7XG5cdFx0Zm9udC1zaXplOiAzcmVtO1xuXHR9XG5cdC50YXJnZXQtY29udGFpbmVyIHtcblx0XHRoZWlnaHQ6IDcwJTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiByb3c7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0ZmxleC13cmFwOiB3cmFwO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0bWFyZ2luOiAwO1xuXHR9XG5cdC50YXJnZXQge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0aGVpZ2h0OiAxMzBweDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRtYXJnaW46IDA7XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblx0LmNvbHVtbiB7XG5cdFx0d2lkdGg6IDE5JTtcblx0XHRtYXgtaGVpZ2h0OiAxMDAlO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcblx0XHRhbGlnbi1jb250ZW50OiBjZW50ZXI7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdG1hcmdpbjogMCAwLjI1cmVtO1xuXHRcdG1hcmdpbjogMDtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHR9XG5cdC5jMSAudGFyZ2V0LFxuXHQuYzMgLnRhcmdldCxcblx0LmM1IC50YXJnZXQge1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICMwZDIyM2Y7XG5cdFx0Y29sb3I6ICM3N2JjNDM7XG5cdH1cblx0LmMyIC50YXJnZXQsXG5cdC5jNCAudGFyZ2V0IHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjNzdiYzQzO1xuXHRcdGNvbG9yOiAjMGQyMjNmO1xuXHR9XG5cdC5jb2xIZWFkaW5nIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGhlaWdodDogMzVweDtcblx0XHRmb250LXNpemU6IDFyZW07XG5cdH1cblx0LmMxIC5jb2xIZWFkaW5nLFxuXHQuYzMgLmNvbEhlYWRpbmcsXG5cdC5jNSAuY29sSGVhZGluZyB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogIzc3YmM0Mztcblx0fVxuXHQuYzIgLmNvbEhlYWRpbmcsXG5cdC5jNCAuY29sSGVhZGluZyB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogIzBkMjIzZjtcblx0XHRjb2xvcjogIzc3YmM0Mztcblx0fVxuXHRAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMTIwcHgpIHtcblx0XHQucGllY2VzLWNvbnRhaW5lciB7XG5cdFx0XHRtYXJnaW4tbGVmdDogOHB4O1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3RpdGxlfTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48ZGl2IGNsYXNzPVwiZ2FtZS1wYWdlXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9PlxuXHQ8ZGl2IGNsYXNzPVwidGFyZ2V0LWNvbnRhaW5lclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4gYzFcIj5cblx0XHRcdDxoMyBjbGFzcz1cImNvbEhlYWRpbmdcIj57Y29sSGVhZGluZ3MuY29sMUhlYWRpbmd9PC9oMz5cblx0XHRcdDxkaXYgaWQ9XCJ0MVwiIGNsYXNzPVwidGFyZ2V0IGNvbDFcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0MlwiIGNsYXNzPVwidGFyZ2V0IGNvbDFcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0M1wiIGNsYXNzPVwidGFyZ2V0IGNvbDFcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uIGMyXCI+XG5cdFx0XHQ8aDMgY2xhc3M9XCJjb2xIZWFkaW5nXCI+e2NvbEhlYWRpbmdzLmNvbDJIZWFkaW5nfTwvaDM+XG5cdFx0XHQ8ZGl2IGlkPVwidDRcIiBjbGFzcz1cInRhcmdldCBjb2wyXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDVcIiBjbGFzcz1cInRhcmdldCBjb2wyXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDZcIiBjbGFzcz1cInRhcmdldCBjb2wyXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImNvbHVtbiBjM1wiPlxuXHRcdFx0PGgzIGNsYXNzPVwiY29sSGVhZGluZ1wiPntjb2xIZWFkaW5ncy5jb2wzSGVhZGluZ308L2gzPlxuXHRcdFx0PGRpdiBpZD1cInQ3XCIgY2xhc3M9XCJ0YXJnZXQgY29sM1wiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQ4XCIgY2xhc3M9XCJ0YXJnZXQgY29sM1wiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQ5XCIgY2xhc3M9XCJ0YXJnZXQgY29sM1wiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4gYzRcIj5cblx0XHRcdDxoMyBjbGFzcz1cImNvbEhlYWRpbmdcIj57Y29sSGVhZGluZ3MuY29sNEhlYWRpbmd9PC9oMz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTBcIiBjbGFzcz1cInRhcmdldCBjb2w0XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDExXCIgY2xhc3M9XCJ0YXJnZXQgY29sNFwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQxMlwiIGNsYXNzPVwidGFyZ2V0IGNvbDRcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uIGM1XCI+XG5cdFx0XHQ8aDMgY2xhc3M9XCJjb2xIZWFkaW5nXCI+e2NvbEhlYWRpbmdzLmNvbDVIZWFkaW5nfTwvaDM+XG5cdFx0XHQ8ZGl2IGlkPVwidDEzXCIgY2xhc3M9XCJ0YXJnZXQgY29sNVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQxNFwiIGNsYXNzPVwidGFyZ2V0IGNvbDVcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTVcIiBjbGFzcz1cInRhcmdldCBjb2w1XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJnYW1lLWJhclwiPlxuXHRcdDxkaXYgb3V0OmZhZGU9e3sgZHVyYXRpb246IDEwIH19IGNsYXNzPVwic2NvcmUtY29udGFpbmVyXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2NvcmUtaXRlbVwiPnRvdGFsIGNvcnJlY3Q6IHskZG5kX3N0b3JlLnRvdGFsQ29ycmVjdH08L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJzY29yZS1pdGVtXCI+dG90YWwgd3Jvbmc6IHskZG5kX3N0b3JlLnRvdGFsV3Jvbmd9PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2NvcmUtaXRlbVwiPnJvdW5kIHtyb3VuZH0gY29ycmVjdDoge3JvdW5kID09PSAxID8gJGRuZF9zdG9yZS5yb3VuZDFDb3JyZWN0IDogJGRuZF9zdG9yZS5yb3VuZDJDb3JyZWN0fTwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cInNjb3JlLWl0ZW1cIj5yb3VuZCB7cm91bmR9IHdyb25nOiB7cm91bmQgPT09IDEgPyAkZG5kX3N0b3JlLnJvdW5kMVdyb25nIDogJGRuZF9zdG9yZS5yb3VuZDJXcm9uZ308L2Rpdj5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJyb3VuZC1sYWJlbFwiIG91dDpmYWRlPXt7IGR1cmF0aW9uOiAxMCB9fT5Sb3VuZCB7cm91bmR9PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwicGllY2VzLWNvbnRhaW5lclwiIGlkPXtyb3VuZCA9PT0gMSA/ICdwaWVjZXNDb250MScgOiAncGllY2VzQ29udDInfSBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0+XG5cdFx0XHR7I2VhY2ggcGllY2VzQXJyYXkgYXMgcGllY2UsIGl9XG5cdFx0XHRcdHsjaWYgcGllY2UuZGVmaW5pdGlvbiB8fCBwaWVjZS5oaW50fVxuXHRcdFx0XHRcdDxkaXYgaW46ZmFkZSBpZD17cGllY2UuaWR9IGNsYXNzPXtgcGllY2VzICR7cGllY2UuY29sfSB0ZXh0YH0gZHJhZ2dhYmxlPVwidHJ1ZVwiIG9uOmRyYWdzdGFydD17ZHJhZ0l0ZW19PlxuXHRcdFx0XHRcdFx0e3BpZWNlLmRlZmluaXRpb24gPyBwaWVjZS5kZWZpbml0aW9uIDogcGllY2UuaGludH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdDxkaXYgaW46ZmFkZSBpZD17cGllY2UuaWR9IGNsYXNzPXtgcGllY2VzICR7cGllY2UuY29sfSBpbWctY29udGFpbmVyYH0gZHJhZ2dhYmxlPVwidHJ1ZVwiPlxuXHRcdFx0XHRcdFx0PGltZyBjbGFzcz1cImltZy1waWVjZVwiIHNyYz17cGllY2UucGljfSBhbHQ9e3BpZWNlLmFsdH0gb246ZHJhZ3N0YXJ0PXtkcmFnSXRlbX0gb246ZHJhZz17aGFuZGxlRHJhZ30gLz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGV4cG9ydCBsZXQgdG90YWxDb3JyZWN0OiBudW1iZXI7XG5cdGV4cG9ydCBsZXQgdG90YWxXcm9uZzogbnVtYmVyO1xuXG5cdGxldCBmaW5hbFNjb3JlOiBudW1iZXI7XG5cdCQ6IHtcblx0XHRsZXQgY2FsY1Njb3JlID0gTWF0aC5yb3VuZCgoKDMwIC0gdG90YWxXcm9uZykgLyAzMCkgKiAxMDApO1xuXHRcdGZpbmFsU2NvcmUgPSBjYWxjU2NvcmUgPj0gMCA/IGNhbGNTY29yZSA6IDA7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC5nYW1lLW92ZXJfY29udGFpbmVyIHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDUwdmg7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LXdyYXA6IHdyYXA7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0fVxuXHQudGl0bGUge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0fVxuXHQuc2NvcmUtY29udGVudCB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZ2FtZS1vdmVyX2NvbnRhaW5lclwiPlxuXHQ8aDEgY2xhc3M9XCJ0aXRsZVwiPkdhbWUgT3ZlcjwvaDE+XG5cdDxoNCBjbGFzcz1cInNjb3JlLWNvbnRlbnRcIj5Ub3RhbCBDb3JyZWN0OiB7dG90YWxDb3JyZWN0fTwvaDQ+XG5cdDxoNCBjbGFzcz1cInNjb3JlLWNvbnRlbnRcIj5Ub3RhbCBXcm9uZzoge3RvdGFsV3Jvbmd9PC9oND5cblx0PGg0IGNsYXNzPVwic2NvcmUtY29udGVudFwiPkZpbmFsIFNjb3JlOiB7ZmluYWxTY29yZX08L2g0PlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBkbmRfc3RvcmUgfSBmcm9tIFwiLi4vc3RvcmVzL2RuZF9nYW1lX3N0b3JlXCI7XG5cdGltcG9ydCBHYW1lQm9hcmQgZnJvbSBcIi4vR2FtZUJvYXJkLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBmYWRlLCBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0aW1wb3J0IEdhbWVPdmVyIGZyb20gXCIuL0dhbWVPdmVyLnN2ZWx0ZVwiO1xuXG5cdGV4cG9ydCBsZXQgZG5kX2NvbnRlbnQ7XG5cdC8vIFRTL1N2ZWx0ZSByZXF1aXJlcyB0aGlzIHBhdHRlcm4gZm9yIHJlYWN0aXZlIGRlY2xhcmF0aW9ucyAoaHR0cHM6Ly9ibG9nLnNjb3R0bG9naWMuY29tLzIwMjAvMDcvMjQvc3ZlbHRlLXRzLmh0bWwpXG5cdGxldCB1cGRhdGVkUm91bmQ6IG51bWJlcjtcblx0JDogdXBkYXRlZFJvdW5kID0gMTtcblxuXHRpbnRlcmZhY2UgQ29sSGVhZGluZ3Mge1xuXHRcdGNvbDFIZWFkaW5nOiBzdHJpbmc7XG5cdFx0Y29sMkhlYWRpbmc6IHN0cmluZztcblx0XHRjb2wzSGVhZGluZzogc3RyaW5nO1xuXHRcdGNvbDRIZWFkaW5nOiBzdHJpbmc7XG5cdFx0Y29sNUhlYWRpbmc6IHN0cmluZztcblx0fVxuXHRsZXQgY29sSGVhZGluZ3M6IENvbEhlYWRpbmdzO1xuXHQkOiBjb2xIZWFkaW5ncyA9IHVwZGF0ZWRSb3VuZCA9PT0gMSA/IGRuZF9jb250ZW50LmRuZGdhbWUxIDogZG5kX2NvbnRlbnQuZG5kZ2FtZTI7XG5cdCQ6IHBpZWNlcyA9IHVwZGF0ZWRSb3VuZCA9PT0gMSA/IGRuZF9jb250ZW50LnBpZWNlczEgOiBkbmRfY29udGVudC5waWVjZXMyO1xuXHQkOiByb3VuZCA9IHVwZGF0ZWRSb3VuZDtcblxuXHRjb25zdCB1cGRhdGVSb3VuZCA9IChlKSA9PiB7XG5cdFx0dXBkYXRlZFJvdW5kID0gZS5kZXRhaWw7XG5cdH07XG48L3NjcmlwdD5cblxueyNpZiB1cGRhdGVkUm91bmQgPT09IDF9XG5cdDxkaXYgaW46ZmFkZT17eyBkdXJhdGlvbjogMzAwIH19IG91dDpmYWRlPXt7IGR1cmF0aW9uOiA1MDAgfX0+XG5cdFx0PEdhbWVCb2FyZCB7ZG5kX3N0b3JlfSB0aXRsZT17ZG5kX2NvbnRlbnQudGl0bGV9IHtjb2xIZWFkaW5nc30ge3BpZWNlc30gb246Y2hlY2tyb3VuZD17dXBkYXRlUm91bmR9IHtyb3VuZH0gLz5cblx0PC9kaXY+XG57OmVsc2UgaWYgdXBkYXRlZFJvdW5kID09PSAyfVxuXHQ8ZGl2IGluOmZhZGU9e3sgZGVsYXk6IDYwMCwgZHVyYXRpb246IDUwMCB9fSBvdXQ6Zmx5PXt7IHg6IDIwMCwgZHVyYXRpb246IDUwMCB9fT5cblx0XHQ8R2FtZUJvYXJkIHtkbmRfc3RvcmV9IHRpdGxlPXtkbmRfY29udGVudC50aXRsZX0ge2NvbEhlYWRpbmdzfSB7cGllY2VzfSBvbjpjaGVja3JvdW5kPXt1cGRhdGVSb3VuZH0ge3JvdW5kfSAvPlxuXHQ8L2Rpdj5cbns6ZWxzZSBpZiB1cGRhdGVkUm91bmQgPT09IDN9XG5cdDxkaXYgaW46Zmx5PXt7IHk6IDIwMCwgZGVsYXk6IDYwMCB9fT5cblx0XHQ8R2FtZU92ZXIgdG90YWxDb3JyZWN0PXskZG5kX3N0b3JlLnRvdGFsQ29ycmVjdH0gdG90YWxXcm9uZz17JGRuZF9zdG9yZS50b3RhbFdyb25nfSAvPlxuXHQ8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQocGFnZSwgc2Vzc2lvbikge1xuXHRcdGNvbnN0IHsgZG5kX3VuaXQgfSA9IHBhZ2UucGFyYW1zO1xuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2goYGRhdGEvJHtkbmRfdW5pdH0uanNvbmApO1xuXHRcdGNvbnN0IGRuZF9jb250ZW50ID0gYXdhaXQgcmVzLmpzb24oKTtcblx0XHRyZXR1cm4geyBkbmRfY29udGVudCB9O1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cblx0aW1wb3J0IERuRCBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9EbkQuc3ZlbHRlXCI7XG5cdGV4cG9ydCBsZXQgZG5kX2NvbnRlbnQ7IC8vIHRoaXMgZ2V0cyBkZWZpbmVkIGluIHNjcmlwdCBtb2R1bGUgYWJvdmVcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT57ZG5kX2NvbnRlbnQudGl0bGV9PC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxEbkQge2RuZF9jb250ZW50fSAvPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQztBQUNoQyxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ2hCLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDZCxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQ2pCLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDZixDQUFDLGFBQWEsRUFBRSxDQUFD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
