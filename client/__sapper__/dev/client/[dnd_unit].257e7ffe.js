import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, r as validate_each_argument, v as validate_slots, u as validate_store, x as subscribe, y as createEventDispatcher, o as onMount, z as empty, l as insert_dev, A as transition_in, p as noop, b as detach_dev, a as space, e as element, t as text, q as query_selector_all, c as claim_space, f as claim_element, h as children, j as claim_text, B as attr_dev, k as add_location, m as append_dev, n as listen_dev, C as set_data_dev, D as create_out_transition, E as destroy_each, F as run_all, G as null_to_empty, I as add_render_callback, J as create_in_transition, K as component_subscribe, L as group_outros, M as transition_out, N as check_outros, O as create_component, P as claim_component, Q as mount_component, R as destroy_component } from './client.4b8e49d1.js';
import { f as fade, a as fly } from './index.002c4e3b.js';

const dnd_store_data = writable({
	totalCorrect: 0,
	totalWrong: 0,
	round1Correct: 0,
	round1Wrong: 0,
	round2Correct: 0,
	round2Wrong: 0,
	firstLoad: true,
});

const dnd_store = {
	subscribe: dnd_store_data.subscribe,
	incCorrectCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Correct: data.round1Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Correct: data.round2Correct + 1,
					totalCorrect: data.totalCorrect + 1,
				};
				return updatedData;
			}
		});
	},
	incWrongCount: (round) => {
		dnd_store_data.update((data) => {
			if (round === 1) {
				const updatedData = {
					...data,
					round1Wrong: data.round1Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			} else if (round === 2) {
				const updatedData = {
					...data,
					round2Wrong: data.round2Wrong + 1,
					totalWrong: data.totalWrong + 1,
				};
				return updatedData;
			}
		});
	},
	resetScores: () => {
		dnd_store_data.set({
			totalCorrect: 0,
			totalWrong: 0,
			round1Correct: 0,
			round1Wrong: 0,
			round2Correct: 0,
			round2Wrong: 0,
			firstLoad: true,
		});
	},
	changeFirstLoad: (newBool) => {
		dnd_store_data.update((data) => {
			const updatedData = {
				...data,
				firstLoad: newBool,
			};
			return updatedData;
		});
	},
};

/* src/components/GameBoard.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "src/components/GameBoard.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	child_ctx[19] = i;
	return child_ctx;
}

// (370:4) {:else}
function create_else_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "img-piece svelte-ctpe5c");
			if (img.src !== (img_src_value = /*piece*/ ctx[17].pic)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*piece*/ ctx[17].alt);
			add_location(img, file, 371, 6, 12069);
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 370, 5, 11974);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img);
			append_dev(div, t);

			if (!mounted) {
				dispose = [
					listen_dev(img, "dragstart", /*dragItem*/ ctx[6], false, false, false),
					listen_dev(img, "drag", /*handleDrag*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && img.src !== (img_src_value = /*piece*/ ctx[17].pic)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*piecesArray*/ 16 && img_alt_value !== (img_alt_value = /*piece*/ ctx[17].alt)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} img-container`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(370:4) {:else}",
		ctx
	});

	return block;
}

// (366:4) {#if piece.definition || piece.hint}
function create_if_block(ctx) {
	let div;

	let t0_value = (/*piece*/ ctx[17].definition
	? /*piece*/ ctx[17].definition
	: /*piece*/ ctx[17].hint) + "";

	let t0;
	let t1;
	let div_id_value;
	let div_class_value;
	let div_intro;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, draggable: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", div_id_value = /*piece*/ ctx[17].id);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"));
			attr_dev(div, "draggable", "true");
			add_location(div, file, 366, 5, 11784);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (!mounted) {
				dispose = listen_dev(div, "dragstart", /*dragItem*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*piecesArray*/ 16 && t0_value !== (t0_value = (/*piece*/ ctx[17].definition
			? /*piece*/ ctx[17].definition
			: /*piece*/ ctx[17].hint) + "")) set_data_dev(t0, t0_value);

			if (dirty & /*piecesArray*/ 16 && div_id_value !== (div_id_value = /*piece*/ ctx[17].id)) {
				attr_dev(div, "id", div_id_value);
			}

			if (dirty & /*piecesArray*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(`pieces ${/*piece*/ ctx[17].col} text`) + " svelte-ctpe5c"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(366:4) {#if piece.definition || piece.hint}",
		ctx
	});

	return block;
}

// (365:3) {#each piecesArray as piece, i}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*piece*/ ctx[17].definition || /*piece*/ ctx[17].hint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(365:3) {#each piecesArray as piece, i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let div29;
	let div20;
	let div3;
	let h30;
	let t1_value = /*colHeadings*/ ctx[1].col1Heading + "";
	let t1;
	let t2;
	let div0;
	let t3;
	let div1;
	let t4;
	let div2;
	let t5;
	let div7;
	let h31;
	let t6_value = /*colHeadings*/ ctx[1].col2Heading + "";
	let t6;
	let t7;
	let div4;
	let t8;
	let div5;
	let t9;
	let div6;
	let t10;
	let div11;
	let h32;
	let t11_value = /*colHeadings*/ ctx[1].col3Heading + "";
	let t11;
	let t12;
	let div8;
	let t13;
	let div9;
	let t14;
	let div10;
	let t15;
	let div15;
	let h33;
	let t16_value = /*colHeadings*/ ctx[1].col4Heading + "";
	let t16;
	let t17;
	let div12;
	let t18;
	let div13;
	let t19;
	let div14;
	let t20;
	let div19;
	let h34;
	let t21_value = /*colHeadings*/ ctx[1].col5Heading + "";
	let t21;
	let t22;
	let div16;
	let t23;
	let div17;
	let t24;
	let div18;
	let t25;
	let div28;
	let div25;
	let div21;
	let t26;
	let t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "";
	let t27;
	let t28;
	let div22;
	let t29;
	let t30_value = /*$dnd_store*/ ctx[5].totalWrong + "";
	let t30;
	let t31;
	let div23;
	let t32;
	let t33;
	let t34;

	let t35_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Correct
	: /*$dnd_store*/ ctx[5].round2Correct) + "";

	let t35;
	let t36;
	let div24;
	let t37;
	let t38;
	let t39;

	let t40_value = (/*round*/ ctx[0] === 1
	? /*$dnd_store*/ ctx[5].round1Wrong
	: /*$dnd_store*/ ctx[5].round2Wrong) + "";

	let t40;
	let div25_outro;
	let t41;
	let div26;
	let t42;
	let t43;
	let div26_outro;
	let t44;
	let div27;
	let div27_id_value;
	let current;
	let mounted;
	let dispose;
	document_1.title = title_value = /*title*/ ctx[2];
	let each_value = /*piecesArray*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			t0 = space();
			div29 = element("div");
			div20 = element("div");
			div3 = element("div");
			h30 = element("h3");
			t1 = text(t1_value);
			t2 = space();
			div0 = element("div");
			t3 = space();
			div1 = element("div");
			t4 = space();
			div2 = element("div");
			t5 = space();
			div7 = element("div");
			h31 = element("h3");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			t8 = space();
			div5 = element("div");
			t9 = space();
			div6 = element("div");
			t10 = space();
			div11 = element("div");
			h32 = element("h3");
			t11 = text(t11_value);
			t12 = space();
			div8 = element("div");
			t13 = space();
			div9 = element("div");
			t14 = space();
			div10 = element("div");
			t15 = space();
			div15 = element("div");
			h33 = element("h3");
			t16 = text(t16_value);
			t17 = space();
			div12 = element("div");
			t18 = space();
			div13 = element("div");
			t19 = space();
			div14 = element("div");
			t20 = space();
			div19 = element("div");
			h34 = element("h3");
			t21 = text(t21_value);
			t22 = space();
			div16 = element("div");
			t23 = space();
			div17 = element("div");
			t24 = space();
			div18 = element("div");
			t25 = space();
			div28 = element("div");
			div25 = element("div");
			div21 = element("div");
			t26 = text("total correct: ");
			t27 = text(t27_value);
			t28 = space();
			div22 = element("div");
			t29 = text("total wrong: ");
			t30 = text(t30_value);
			t31 = space();
			div23 = element("div");
			t32 = text("round ");
			t33 = text(/*round*/ ctx[0]);
			t34 = text(" correct: ");
			t35 = text(t35_value);
			t36 = space();
			div24 = element("div");
			t37 = text("round ");
			t38 = text(/*round*/ ctx[0]);
			t39 = text(" wrong: ");
			t40 = text(t40_value);
			t41 = space();
			div26 = element("div");
			t42 = text("Round ");
			t43 = text(/*round*/ ctx[0]);
			t44 = space();
			div27 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1az6e94\"]", document_1.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div29 = claim_element(nodes, "DIV", { class: true });
			var div29_nodes = children(div29);
			div20 = claim_element(div29_nodes, "DIV", { class: true });
			var div20_nodes = children(div20);
			div3 = claim_element(div20_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			h30 = claim_element(div3_nodes, "H3", { class: true });
			var h30_nodes = children(h30);
			t1 = claim_text(h30_nodes, t1_value);
			h30_nodes.forEach(detach_dev);
			t2 = claim_space(div3_nodes);
			div0 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div1).forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { id: true, class: true });
			children(div2).forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t5 = claim_space(div20_nodes);
			div7 = claim_element(div20_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			h31 = claim_element(div7_nodes, "H3", { class: true });
			var h31_nodes = children(h31);
			t6 = claim_text(h31_nodes, t6_value);
			h31_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			div4 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div4).forEach(detach_dev);
			t8 = claim_space(div7_nodes);
			div5 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div5).forEach(detach_dev);
			t9 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { id: true, class: true });
			children(div6).forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			t10 = claim_space(div20_nodes);
			div11 = claim_element(div20_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h32 = claim_element(div11_nodes, "H3", { class: true });
			var h32_nodes = children(h32);
			t11 = claim_text(h32_nodes, t11_value);
			h32_nodes.forEach(detach_dev);
			t12 = claim_space(div11_nodes);
			div8 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div8).forEach(detach_dev);
			t13 = claim_space(div11_nodes);
			div9 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div9).forEach(detach_dev);
			t14 = claim_space(div11_nodes);
			div10 = claim_element(div11_nodes, "DIV", { id: true, class: true });
			children(div10).forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			t15 = claim_space(div20_nodes);
			div15 = claim_element(div20_nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			h33 = claim_element(div15_nodes, "H3", { class: true });
			var h33_nodes = children(h33);
			t16 = claim_text(h33_nodes, t16_value);
			h33_nodes.forEach(detach_dev);
			t17 = claim_space(div15_nodes);
			div12 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div12).forEach(detach_dev);
			t18 = claim_space(div15_nodes);
			div13 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div13).forEach(detach_dev);
			t19 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { id: true, class: true });
			children(div14).forEach(detach_dev);
			div15_nodes.forEach(detach_dev);
			t20 = claim_space(div20_nodes);
			div19 = claim_element(div20_nodes, "DIV", { class: true });
			var div19_nodes = children(div19);
			h34 = claim_element(div19_nodes, "H3", { class: true });
			var h34_nodes = children(h34);
			t21 = claim_text(h34_nodes, t21_value);
			h34_nodes.forEach(detach_dev);
			t22 = claim_space(div19_nodes);
			div16 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div16).forEach(detach_dev);
			t23 = claim_space(div19_nodes);
			div17 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div17).forEach(detach_dev);
			t24 = claim_space(div19_nodes);
			div18 = claim_element(div19_nodes, "DIV", { id: true, class: true });
			children(div18).forEach(detach_dev);
			div19_nodes.forEach(detach_dev);
			div20_nodes.forEach(detach_dev);
			t25 = claim_space(div29_nodes);
			div28 = claim_element(div29_nodes, "DIV", { class: true });
			var div28_nodes = children(div28);
			div25 = claim_element(div28_nodes, "DIV", { class: true });
			var div25_nodes = children(div25);
			div21 = claim_element(div25_nodes, "DIV", { class: true });
			var div21_nodes = children(div21);
			t26 = claim_text(div21_nodes, "total correct: ");
			t27 = claim_text(div21_nodes, t27_value);
			div21_nodes.forEach(detach_dev);
			t28 = claim_space(div25_nodes);
			div22 = claim_element(div25_nodes, "DIV", { class: true });
			var div22_nodes = children(div22);
			t29 = claim_text(div22_nodes, "total wrong: ");
			t30 = claim_text(div22_nodes, t30_value);
			div22_nodes.forEach(detach_dev);
			t31 = claim_space(div25_nodes);
			div23 = claim_element(div25_nodes, "DIV", { class: true });
			var div23_nodes = children(div23);
			t32 = claim_text(div23_nodes, "round ");
			t33 = claim_text(div23_nodes, /*round*/ ctx[0]);
			t34 = claim_text(div23_nodes, " correct: ");
			t35 = claim_text(div23_nodes, t35_value);
			div23_nodes.forEach(detach_dev);
			t36 = claim_space(div25_nodes);
			div24 = claim_element(div25_nodes, "DIV", { class: true });
			var div24_nodes = children(div24);
			t37 = claim_text(div24_nodes, "round ");
			t38 = claim_text(div24_nodes, /*round*/ ctx[0]);
			t39 = claim_text(div24_nodes, " wrong: ");
			t40 = claim_text(div24_nodes, t40_value);
			div24_nodes.forEach(detach_dev);
			div25_nodes.forEach(detach_dev);
			t41 = claim_space(div28_nodes);
			div26 = claim_element(div28_nodes, "DIV", { class: true });
			var div26_nodes = children(div26);
			t42 = claim_text(div26_nodes, "Round ");
			t43 = claim_text(div26_nodes, /*round*/ ctx[0]);
			div26_nodes.forEach(detach_dev);
			t44 = claim_space(div28_nodes);
			div27 = claim_element(div28_nodes, "DIV", { class: true, id: true });
			var div27_nodes = children(div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div27_nodes);
			}

			div27_nodes.forEach(detach_dev);
			div28_nodes.forEach(detach_dev);
			div29_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h30, "class", "colHeading svelte-ctpe5c");
			add_location(h30, file, 322, 3, 9346);
			attr_dev(div0, "id", "t1");
			attr_dev(div0, "class", "target col1 svelte-ctpe5c");
			add_location(div0, file, 323, 3, 9403);
			attr_dev(div1, "id", "t2");
			attr_dev(div1, "class", "target col1 svelte-ctpe5c");
			add_location(div1, file, 324, 3, 9485);
			attr_dev(div2, "id", "t3");
			attr_dev(div2, "class", "target col1 svelte-ctpe5c");
			add_location(div2, file, 325, 3, 9567);
			attr_dev(div3, "class", "column c1 svelte-ctpe5c");
			add_location(div3, file, 321, 2, 9319);
			attr_dev(h31, "class", "colHeading svelte-ctpe5c");
			add_location(h31, file, 328, 3, 9684);
			attr_dev(div4, "id", "t4");
			attr_dev(div4, "class", "target col2 svelte-ctpe5c");
			add_location(div4, file, 329, 3, 9741);
			attr_dev(div5, "id", "t5");
			attr_dev(div5, "class", "target col2 svelte-ctpe5c");
			add_location(div5, file, 330, 3, 9823);
			attr_dev(div6, "id", "t6");
			attr_dev(div6, "class", "target col2 svelte-ctpe5c");
			add_location(div6, file, 331, 3, 9905);
			attr_dev(div7, "class", "column c2 svelte-ctpe5c");
			add_location(div7, file, 327, 2, 9657);
			attr_dev(h32, "class", "colHeading svelte-ctpe5c");
			add_location(h32, file, 334, 3, 10022);
			attr_dev(div8, "id", "t7");
			attr_dev(div8, "class", "target col3 svelte-ctpe5c");
			add_location(div8, file, 335, 3, 10079);
			attr_dev(div9, "id", "t8");
			attr_dev(div9, "class", "target col3 svelte-ctpe5c");
			add_location(div9, file, 336, 3, 10161);
			attr_dev(div10, "id", "t9");
			attr_dev(div10, "class", "target col3 svelte-ctpe5c");
			add_location(div10, file, 337, 3, 10243);
			attr_dev(div11, "class", "column c3 svelte-ctpe5c");
			add_location(div11, file, 333, 2, 9995);
			attr_dev(h33, "class", "colHeading svelte-ctpe5c");
			add_location(h33, file, 340, 3, 10360);
			attr_dev(div12, "id", "t10");
			attr_dev(div12, "class", "target col4 svelte-ctpe5c");
			add_location(div12, file, 341, 3, 10417);
			attr_dev(div13, "id", "t11");
			attr_dev(div13, "class", "target col4 svelte-ctpe5c");
			add_location(div13, file, 342, 3, 10500);
			attr_dev(div14, "id", "t12");
			attr_dev(div14, "class", "target col4 svelte-ctpe5c");
			add_location(div14, file, 343, 3, 10583);
			attr_dev(div15, "class", "column c4 svelte-ctpe5c");
			add_location(div15, file, 339, 2, 10333);
			attr_dev(h34, "class", "colHeading svelte-ctpe5c");
			add_location(h34, file, 346, 3, 10701);
			attr_dev(div16, "id", "t13");
			attr_dev(div16, "class", "target col5 svelte-ctpe5c");
			add_location(div16, file, 347, 3, 10758);
			attr_dev(div17, "id", "t14");
			attr_dev(div17, "class", "target col5 svelte-ctpe5c");
			add_location(div17, file, 348, 3, 10841);
			attr_dev(div18, "id", "t15");
			attr_dev(div18, "class", "target col5 svelte-ctpe5c");
			add_location(div18, file, 349, 3, 10924);
			attr_dev(div19, "class", "column c5 svelte-ctpe5c");
			add_location(div19, file, 345, 2, 10674);
			attr_dev(div20, "class", "target-container svelte-ctpe5c");
			add_location(div20, file, 320, 1, 9286);
			attr_dev(div21, "class", "score-item svelte-ctpe5c");
			add_location(div21, file, 355, 3, 11109);
			attr_dev(div22, "class", "score-item svelte-ctpe5c");
			add_location(div22, file, 356, 3, 11183);
			attr_dev(div23, "class", "score-item svelte-ctpe5c");
			add_location(div23, file, 357, 3, 11253);
			attr_dev(div24, "class", "score-item svelte-ctpe5c");
			add_location(div24, file, 358, 3, 11377);
			attr_dev(div25, "class", "score-container svelte-ctpe5c");
			add_location(div25, file, 354, 2, 11048);
			attr_dev(div26, "class", "round-label svelte-ctpe5c");
			add_location(div26, file, 361, 2, 11504);
			attr_dev(div27, "class", "pieces-container svelte-ctpe5c");
			attr_dev(div27, "id", div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2");
			add_location(div27, file, 363, 2, 11580);
			attr_dev(div28, "class", "game-bar svelte-ctpe5c");
			add_location(div28, file, 353, 1, 11023);
			attr_dev(div29, "class", "game-page svelte-ctpe5c");
			add_location(div29, file, 319, 0, 9218);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div29, anchor);
			append_dev(div29, div20);
			append_dev(div20, div3);
			append_dev(div3, h30);
			append_dev(h30, t1);
			append_dev(div3, t2);
			append_dev(div3, div0);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div20, t5);
			append_dev(div20, div7);
			append_dev(div7, h31);
			append_dev(h31, t6);
			append_dev(div7, t7);
			append_dev(div7, div4);
			append_dev(div7, t8);
			append_dev(div7, div5);
			append_dev(div7, t9);
			append_dev(div7, div6);
			append_dev(div20, t10);
			append_dev(div20, div11);
			append_dev(div11, h32);
			append_dev(h32, t11);
			append_dev(div11, t12);
			append_dev(div11, div8);
			append_dev(div11, t13);
			append_dev(div11, div9);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div20, t15);
			append_dev(div20, div15);
			append_dev(div15, h33);
			append_dev(h33, t16);
			append_dev(div15, t17);
			append_dev(div15, div12);
			append_dev(div15, t18);
			append_dev(div15, div13);
			append_dev(div15, t19);
			append_dev(div15, div14);
			append_dev(div20, t20);
			append_dev(div20, div19);
			append_dev(div19, h34);
			append_dev(h34, t21);
			append_dev(div19, t22);
			append_dev(div19, div16);
			append_dev(div19, t23);
			append_dev(div19, div17);
			append_dev(div19, t24);
			append_dev(div19, div18);
			append_dev(div29, t25);
			append_dev(div29, div28);
			append_dev(div28, div25);
			append_dev(div25, div21);
			append_dev(div21, t26);
			append_dev(div21, t27);
			append_dev(div25, t28);
			append_dev(div25, div22);
			append_dev(div22, t29);
			append_dev(div22, t30);
			append_dev(div25, t31);
			append_dev(div25, div23);
			append_dev(div23, t32);
			append_dev(div23, t33);
			append_dev(div23, t34);
			append_dev(div23, t35);
			append_dev(div25, t36);
			append_dev(div25, div24);
			append_dev(div24, t37);
			append_dev(div24, t38);
			append_dev(div24, t39);
			append_dev(div24, t40);
			append_dev(div28, t41);
			append_dev(div28, div26);
			append_dev(div26, t42);
			append_dev(div26, t43);
			append_dev(div28, t44);
			append_dev(div28, div27);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div27, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div0, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div1, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div1, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div2, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div2, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div4, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div4, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div5, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div5, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div6, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div6, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div8, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div8, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div9, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div9, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div10, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div10, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div12, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div12, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div13, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div13, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div14, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div14, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div16, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div16, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div17, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div17, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div18, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div18, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div27, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div27, "dragover", /*allowDrop*/ ctx[8], false, false, false),
					listen_dev(div29, "drop", /*dropItem*/ ctx[7], false, false, false),
					listen_dev(div29, "dragover", /*allowDrop*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 4) && title_value !== (title_value = /*title*/ ctx[2])) {
				document_1.title = title_value;
			}

			if ((!current || dirty & /*colHeadings*/ 2) && t1_value !== (t1_value = /*colHeadings*/ ctx[1].col1Heading + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t6_value !== (t6_value = /*colHeadings*/ ctx[1].col2Heading + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t11_value !== (t11_value = /*colHeadings*/ ctx[1].col3Heading + "")) set_data_dev(t11, t11_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t16_value !== (t16_value = /*colHeadings*/ ctx[1].col4Heading + "")) set_data_dev(t16, t16_value);
			if ((!current || dirty & /*colHeadings*/ 2) && t21_value !== (t21_value = /*colHeadings*/ ctx[1].col5Heading + "")) set_data_dev(t21, t21_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t27_value !== (t27_value = /*$dnd_store*/ ctx[5].totalCorrect + "")) set_data_dev(t27, t27_value);
			if ((!current || dirty & /*$dnd_store*/ 32) && t30_value !== (t30_value = /*$dnd_store*/ ctx[5].totalWrong + "")) set_data_dev(t30, t30_value);
			if (!current || dirty & /*round*/ 1) set_data_dev(t33, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t35_value !== (t35_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Correct
			: /*$dnd_store*/ ctx[5].round2Correct) + "")) set_data_dev(t35, t35_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t38, /*round*/ ctx[0]);

			if ((!current || dirty & /*round, $dnd_store*/ 33) && t40_value !== (t40_value = (/*round*/ ctx[0] === 1
			? /*$dnd_store*/ ctx[5].round1Wrong
			: /*$dnd_store*/ ctx[5].round2Wrong) + "")) set_data_dev(t40, t40_value);

			if (!current || dirty & /*round*/ 1) set_data_dev(t43, /*round*/ ctx[0]);

			if (dirty & /*piecesArray, dragItem, handleDrag*/ 592) {
				each_value = /*piecesArray*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div27, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*round*/ 1 && div27_id_value !== (div27_id_value = /*round*/ ctx[0] === 1 ? "piecesCont1" : "piecesCont2")) {
				attr_dev(div27, "id", div27_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (div25_outro) div25_outro.end(1);
			if (div26_outro) div26_outro.end(1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			div25_outro = create_out_transition(div25, fade, { duration: 10 });
			div26_outro = create_out_transition(div26, fade, { duration: 10 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div29);
			if (detaching && div25_outro) div25_outro.end();
			if (detaching && div26_outro) div26_outro.end();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $dnd_store,
		$$unsubscribe_dnd_store = noop,
		$$subscribe_dnd_store = () => ($$unsubscribe_dnd_store(), $$unsubscribe_dnd_store = subscribe(dnd_store, $$value => $$invalidate(5, $dnd_store = $$value)), dnd_store);

	$$self.$$.on_destroy.push(() => $$unsubscribe_dnd_store());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameBoard", slots, []);
	let { colHeadings } = $$props;
	let { pieces } = $$props;
	let { round } = $$props;
	let { title } = $$props;
	let { dnd_store } = $$props;
	validate_store(dnd_store, "dnd_store");
	$$subscribe_dnd_store();
	let piecesArray = [];
	let piecesLeft = 30;
	const dispatch = createEventDispatcher();

	onMount(() => {
		$$invalidate(4, piecesArray = [...pieces]);
		$$invalidate(4, piecesArray = shuffleArray(piecesArray));

		// firstLoad starts as true, and is immediately turned false
		// this will affect score reset onMount so that round 2 is not reset
		// but reset will happen when coming back after game is over
		dnd_store.changeFirstLoad(false);
	});

	const shuffleArray = array => {
		// copy array to manipulate
		let arrayCopy = [...array];

		let mixedArray = [];

		// loop through copy until no elements left
		while (arrayCopy.length > 0) {
			let randNum = Math.floor(Math.random() * arrayCopy.length);

			// add removed elements to mixedArray as looping occurs
			mixedArray.push(arrayCopy.splice(randNum, 1)[0]);
		}

		return mixedArray;
	};

	const dragItem = e => {
		if (e.target.tagName === "IMG") {
			e.dataTransfer.setData("text", e.target.parentNode.id);
		} else {
			e.dataTransfer.setData("text", e.target.id);
		}
	};

	const dropItem = e => {
		// define pieces container to allow drop of item back into original spot
		let isPiecesContainer = hasClass(e.target, "pieces-container");

		// let parent = e.target.parentNode;
		let dragItemId = e.dataTransfer.getData("text");

		let dragItem = document.getElementById(dragItemId);

		// if target to drop in is empty or the target is the pices container, you can drop item in
		if (!e.target.firstChild || isPiecesContainer) {
			// if the target is not the pieces container
			if (!isPiecesContainer) {
				// setting to static position so the div will be relative to parent
				dragItem.style.position = "static";

				// must make visible again because I am hadding all stacked pieces in
				// the pieces container to display only the top piece so as to not
				// stack box-shadows
				dragItem.style.visibility = "visible";

				//
				if (// check if parent has the odd numbered classes to adjust font color
				hasClass(e.target, "col1") || hasClass(e.target, "col3") || hasClass(e.target, "col5")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#0d223f"; // navy blue
					dragItem.style.color = "#77bc43";
				} else if (hasClass(e.target, "col2") || hasClass(e.target, "col4")) {
					dragItem.style.backgroundColor = "transparent";
					e.target.style.backgroundColor = "#77bc43"; // green
					dragItem.style.color = "#0d223f";
				}

				if (!checkIsMatch(e.target, dragItem)) {
					dnd_store.incWrongCount(round);
					e.target.style.backgroundColor = "#bf1d1d"; // bg = red
					dragItem.style.color = "#e8e1e1"; // font color = light gray
				} else if (checkIsMatch(e.target, dragItem)) {
					dnd_store.incCorrectCount(round);

					//using children[0] works for image, but I do want to check the node, not just child elem.
					// so children[0] results in break
					console.log("dragItem", dragItem.children.length);

					if (dragItem.childNodes[0].tagName === "IMG") {
						console.log("this is an image: ", dragItem);
						dragItem.childNodes[0].setAttribute("draggable", "false");
						dragItem.childNodes[0].style.cursor = "no-drop";
						dragItem.style.maxHeight = "110px";
					} else {
						dragItem.style.overflow = "auto";
					}

					dragItem.setAttribute("draggable", "false");
					dragItem.style.border = "none";
					dragItem.style.userSelect = "none";
					dragItem.style.boxShadow = "none";
					dragItem.style.cursor = "no-drop";
				}
			} else if (isPiecesContainer) {
				// if being placed back in the pieces container, going back to absolute and resetting bkgrnd & font color
				dragItem.style.position = "absolute";

				dragItem.style.backgroundColor = "rgb(115, 167, 167)";
				dragItem.style.color = "rgb(15, 21, 21)";
			}

			// now the actual placement occurs
			e.preventDefault();

			e.target.appendChild(dragItem);

			let piecesCont = round === 1
			? document.getElementById("piecesCont1")
			: document.getElementById("piecesCont2");

			$$invalidate(11, piecesLeft = checkPiecesLeft(piecesCont));
		}
	};

	const allowDrop = e => {
		e.preventDefault();
	};

	const handleDrag = e => {
		e.target.style.cursor = "grabbing";
	};

	const checkIsMatch = (target, dragItem) => {
		if (hasClass(target, "col1") && hasClass(dragItem, "col1")) {
			return true;
		} else if (hasClass(target, "col2") && hasClass(dragItem, "col2")) {
			return true;
		} else if (hasClass(target, "col3") && hasClass(dragItem, "col3")) {
			return true;
		} else if (hasClass(target, "col4") && hasClass(dragItem, "col4")) {
			return true;
		} else if (hasClass(target, "col5") && hasClass(dragItem, "col5")) {
			return true;
		} else {
			return false;
		}
	};

	const hasClass = (el, clss) => {
		return el.classList.contains(clss);
	};

	const checkPiecesLeft = el => {
		const numChildNodes = el.childNodes.length;
		return numChildNodes;
	};

	const writable_props = ["colHeadings", "pieces", "round", "title", "dnd_store"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GameBoard> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
	};

	$$self.$capture_state = () => ({
		onMount,
		createEventDispatcher,
		fade,
		colHeadings,
		pieces,
		round,
		title,
		dnd_store,
		piecesArray,
		piecesLeft,
		dispatch,
		shuffleArray,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		checkIsMatch,
		hasClass,
		checkPiecesLeft,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("colHeadings" in $$props) $$invalidate(1, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(10, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(0, round = $$props.round);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("dnd_store" in $$props) $$subscribe_dnd_store($$invalidate(3, dnd_store = $$props.dnd_store));
		if ("piecesArray" in $$props) $$invalidate(4, piecesArray = $$props.piecesArray);
		if ("piecesLeft" in $$props) $$invalidate(11, piecesLeft = $$props.piecesLeft);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*piecesLeft, round*/ 2049) {
			 if (piecesLeft <= 15) {
				// if current round is 1, then change to 2, else change to 3
				$$invalidate(0, round = round === 1 ? 2 : 3);

				dispatch("checkround", round);
			}
		}

		if ($$self.$$.dirty & /*$dnd_store, round, dnd_store*/ 41) {
			 {
				if (!$dnd_store.firstLoad && round === 1) {
					// reset only if game has been loaded and user is back to round 1
					dnd_store.resetScores();
				}
			}
		}
	};

	return [
		round,
		colHeadings,
		title,
		dnd_store,
		piecesArray,
		$dnd_store,
		dragItem,
		dropItem,
		allowDrop,
		handleDrag,
		pieces
	];
}

class GameBoard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			colHeadings: 1,
			pieces: 10,
			round: 0,
			title: 2,
			dnd_store: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameBoard",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*colHeadings*/ ctx[1] === undefined && !("colHeadings" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'colHeadings'");
		}

		if (/*pieces*/ ctx[10] === undefined && !("pieces" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'pieces'");
		}

		if (/*round*/ ctx[0] === undefined && !("round" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'round'");
		}

		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'title'");
		}

		if (/*dnd_store*/ ctx[3] === undefined && !("dnd_store" in props)) {
			console_1.warn("<GameBoard> was created without expected prop 'dnd_store'");
		}
	}

	get colHeadings() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colHeadings(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pieces() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pieces(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dnd_store() {
		throw new Error("<GameBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_store(value) {
		throw new Error("<GameBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/GameOver.svelte generated by Svelte v3.29.0 */

const file$1 = "src/components/GameOver.svelte";

function create_fragment$1(ctx) {
	let div;
	let h1;
	let t0;
	let t1;
	let h40;
	let t2;
	let t3;
	let t4;
	let h41;
	let t5;
	let t6;
	let t7;
	let h42;
	let t8;
	let t9;

	const block = {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Game Over");
			t1 = space();
			h40 = element("h4");
			t2 = text("Total Correct: ");
			t3 = text(/*totalCorrect*/ ctx[0]);
			t4 = space();
			h41 = element("h4");
			t5 = text("Total Wrong: ");
			t6 = text(/*totalWrong*/ ctx[1]);
			t7 = space();
			h42 = element("h4");
			t8 = text("Final Score: ");
			t9 = text(/*finalScore*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Game Over");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			h40 = claim_element(div_nodes, "H4", { class: true });
			var h40_nodes = children(h40);
			t2 = claim_text(h40_nodes, "Total Correct: ");
			t3 = claim_text(h40_nodes, /*totalCorrect*/ ctx[0]);
			h40_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			h41 = claim_element(div_nodes, "H4", { class: true });
			var h41_nodes = children(h41);
			t5 = claim_text(h41_nodes, "Total Wrong: ");
			t6 = claim_text(h41_nodes, /*totalWrong*/ ctx[1]);
			h41_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			h42 = claim_element(div_nodes, "H4", { class: true });
			var h42_nodes = children(h42);
			t8 = claim_text(h42_nodes, "Final Score: ");
			t9 = claim_text(h42_nodes, /*finalScore*/ ctx[2]);
			h42_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "title svelte-1g63pp");
			add_location(h1, file$1, 29, 1, 518);
			attr_dev(h40, "class", "score-content svelte-1g63pp");
			add_location(h40, file$1, 30, 1, 552);
			attr_dev(h41, "class", "score-content svelte-1g63pp");
			add_location(h41, file$1, 31, 1, 614);
			attr_dev(h42, "class", "score-content svelte-1g63pp");
			add_location(h42, file$1, 32, 1, 672);
			attr_dev(div, "class", "game-over_container svelte-1g63pp");
			add_location(div, file$1, 28, 0, 483);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t0);
			append_dev(div, t1);
			append_dev(div, h40);
			append_dev(h40, t2);
			append_dev(h40, t3);
			append_dev(div, t4);
			append_dev(div, h41);
			append_dev(h41, t5);
			append_dev(h41, t6);
			append_dev(div, t7);
			append_dev(div, h42);
			append_dev(h42, t8);
			append_dev(h42, t9);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*totalCorrect*/ 1) set_data_dev(t3, /*totalCorrect*/ ctx[0]);
			if (dirty & /*totalWrong*/ 2) set_data_dev(t6, /*totalWrong*/ ctx[1]);
			if (dirty & /*finalScore*/ 4) set_data_dev(t9, /*finalScore*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GameOver", slots, []);
	let { totalCorrect } = $$props;
	let { totalWrong } = $$props;
	let finalScore;
	const writable_props = ["totalCorrect", "totalWrong"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GameOver> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
	};

	$$self.$capture_state = () => ({ totalCorrect, totalWrong, finalScore });

	$$self.$inject_state = $$props => {
		if ("totalCorrect" in $$props) $$invalidate(0, totalCorrect = $$props.totalCorrect);
		if ("totalWrong" in $$props) $$invalidate(1, totalWrong = $$props.totalWrong);
		if ("finalScore" in $$props) $$invalidate(2, finalScore = $$props.finalScore);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*totalWrong*/ 2) {
			 {
				let calcScore = Math.round((30 - totalWrong) / 30 * 100);
				$$invalidate(2, finalScore = calcScore >= 0 ? calcScore : 0);
			}
		}
	};

	return [totalCorrect, totalWrong, finalScore];
}

class GameOver extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { totalCorrect: 0, totalWrong: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GameOver",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*totalCorrect*/ ctx[0] === undefined && !("totalCorrect" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalCorrect'");
		}

		if (/*totalWrong*/ ctx[1] === undefined && !("totalWrong" in props)) {
			console.warn("<GameOver> was created without expected prop 'totalWrong'");
		}
	}

	get totalCorrect() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalCorrect(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get totalWrong() {
		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set totalWrong(value) {
		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/DnD.svelte generated by Svelte v3.29.0 */
const file$2 = "src/components/DnD.svelte";

// (26:29) 
function create_if_block_2(ctx) {
	let div;
	let gameover;
	let div_intro;
	let current;

	gameover = new GameOver({
			props: {
				totalCorrect: /*$dnd_store*/ ctx[5].totalCorrect,
				totalWrong: /*$dnd_store*/ ctx[5].totalWrong
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameover.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameover.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 26, 1, 1133);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameover, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameover_changes = {};
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalCorrect = /*$dnd_store*/ ctx[5].totalCorrect;
			if (dirty & /*$dnd_store*/ 32) gameover_changes.totalWrong = /*$dnd_store*/ ctx[5].totalWrong;
			gameover.$set(gameover_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameover.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { y: 200, delay: 600 });
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(gameover.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameover);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(26:29) ",
		ctx
	});

	return block;
}

// (22:29) 
function create_if_block_1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 22, 1, 899);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { delay: 600, duration: 500 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fly, { x: 200, duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(22:29) ",
		ctx
	});

	return block;
}

// (18:0) {#if updatedRound === 1}
function create_if_block$1(ctx) {
	let div;
	let gameboard;
	let div_intro;
	let div_outro;
	let current;

	gameboard = new GameBoard({
			props: {
				dnd_store,
				title: /*dnd_content*/ ctx[0].title,
				colHeadings: /*colHeadings*/ ctx[2],
				pieces: /*pieces*/ ctx[3],
				round: /*round*/ ctx[4]
			},
			$$inline: true
		});

	gameboard.$on("checkround", /*updateRound*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gameboard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(gameboard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 18, 1, 684);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gameboard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gameboard_changes = {};
			if (dirty & /*dnd_content*/ 1) gameboard_changes.title = /*dnd_content*/ ctx[0].title;
			if (dirty & /*colHeadings*/ 4) gameboard_changes.colHeadings = /*colHeadings*/ ctx[2];
			if (dirty & /*pieces*/ 8) gameboard_changes.pieces = /*pieces*/ ctx[3];
			if (dirty & /*round*/ 16) gameboard_changes.round = /*round*/ ctx[4];
			gameboard.$set(gameboard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gameboard.$$.fragment, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, { duration: 300 });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(gameboard.$$.fragment, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fade, { duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gameboard);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(18:0) {#if updatedRound === 1}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*updatedRound*/ ctx[1] === 1) return 0;
		if (/*updatedRound*/ ctx[1] === 2) return 1;
		if (/*updatedRound*/ ctx[1] === 3) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $dnd_store;
	validate_store(dnd_store, "dnd_store");
	component_subscribe($$self, dnd_store, $$value => $$invalidate(5, $dnd_store = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DnD", slots, []);
	let { dnd_content } = $$props;

	// TS/Svelte requires this pattern for reactive declarations (https://blog.scottlogic.com/2020/07/24/svelte-ts.html)
	let updatedRound;

	let colHeadings;

	const updateRound = e => {
		$$invalidate(1, updatedRound = e.detail);
	};

	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DnD> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({
		dnd_store,
		GameBoard,
		fade,
		fly,
		GameOver,
		dnd_content,
		updatedRound,
		colHeadings,
		updateRound,
		pieces,
		round,
		$dnd_store
	});

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
		if ("updatedRound" in $$props) $$invalidate(1, updatedRound = $$props.updatedRound);
		if ("colHeadings" in $$props) $$invalidate(2, colHeadings = $$props.colHeadings);
		if ("pieces" in $$props) $$invalidate(3, pieces = $$props.pieces);
		if ("round" in $$props) $$invalidate(4, round = $$props.round);
	};

	let pieces;
	let round;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(2, colHeadings = updatedRound === 1
			? dnd_content.dndgame1
			: dnd_content.dndgame2);
		}

		if ($$self.$$.dirty & /*updatedRound, dnd_content*/ 3) {
			 $$invalidate(3, pieces = updatedRound === 1
			? dnd_content.pieces1
			: dnd_content.pieces2);
		}

		if ($$self.$$.dirty & /*updatedRound*/ 2) {
			 $$invalidate(4, round = updatedRound);
		}
	};

	 $$invalidate(1, updatedRound = 1);
	return [dnd_content, updatedRound, colHeadings, pieces, round, $dnd_store, updateRound];
}

class DnD extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DnD",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<DnD> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<DnD>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<DnD>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/dndgame/[dnd_unit].svelte generated by Svelte v3.29.0 */

function create_fragment$3(ctx) {
	let title_value;
	let t;
	let dnd;
	let current;
	document.title = title_value = /*dnd_content*/ ctx[0].title;

	dnd = new DnD({
			props: { dnd_content: /*dnd_content*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t = space();
			create_component(dnd.$$.fragment);
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-8wlx8a\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(dnd.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			mount_component(dnd, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*dnd_content*/ 1) && title_value !== (title_value = /*dnd_content*/ ctx[0].title)) {
				document.title = title_value;
			}

			const dnd_changes = {};
			if (dirty & /*dnd_content*/ 1) dnd_changes.dnd_content = /*dnd_content*/ ctx[0];
			dnd.$set(dnd_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dnd.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dnd.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			destroy_component(dnd, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload(page, session) {
	const { dnd_unit } = page.params;
	const res = await this.fetch(`data/${dnd_unit}.json`);
	const dnd_content = await res.json();
	return { dnd_content };
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("U5Bdnd_unitu5D", slots, []);
	let { dnd_content } = $$props; // this gets defined in script module above
	const writable_props = ["dnd_content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bdnd_unitu5D> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	$$self.$capture_state = () => ({ preload, DnD, dnd_content });

	$$self.$inject_state = $$props => {
		if ("dnd_content" in $$props) $$invalidate(0, dnd_content = $$props.dnd_content);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dnd_content];
}

class U5Bdnd_unitu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { dnd_content: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bdnd_unitu5D",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*dnd_content*/ ctx[0] === undefined && !("dnd_content" in props)) {
			console.warn("<U5Bdnd_unitu5D> was created without expected prop 'dnd_content'");
		}
	}

	get dnd_content() {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dnd_content(value) {
		throw new Error("<U5Bdnd_unitu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bdnd_unitu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2RuZF91bml0XS4yNTdlN2ZmZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3Jlcy9kbmRfZ2FtZV9zdG9yZS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0dhbWVCb2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9HYW1lT3Zlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9EbkQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kbmRnYW1lL1tkbmRfdW5pdF0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBkbmRfc3RvcmVfZGF0YSA9IHdyaXRhYmxlKHtcblx0dG90YWxDb3JyZWN0OiAwLFxuXHR0b3RhbFdyb25nOiAwLFxuXHRyb3VuZDFDb3JyZWN0OiAwLFxuXHRyb3VuZDFXcm9uZzogMCxcblx0cm91bmQyQ29ycmVjdDogMCxcblx0cm91bmQyV3Jvbmc6IDAsXG5cdGZpcnN0TG9hZDogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZG5kX3N0b3JlID0ge1xuXHRzdWJzY3JpYmU6IGRuZF9zdG9yZV9kYXRhLnN1YnNjcmliZSxcblx0aW5jQ29ycmVjdENvdW50OiAocm91bmQpID0+IHtcblx0XHRkbmRfc3RvcmVfZGF0YS51cGRhdGUoKGRhdGEpID0+IHtcblx0XHRcdGlmIChyb3VuZCA9PT0gMSkge1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0XHQuLi5kYXRhLFxuXHRcdFx0XHRcdHJvdW5kMUNvcnJlY3Q6IGRhdGEucm91bmQxQ29ycmVjdCArIDEsXG5cdFx0XHRcdFx0dG90YWxDb3JyZWN0OiBkYXRhLnRvdGFsQ29ycmVjdCArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJDb3JyZWN0OiBkYXRhLnJvdW5kMkNvcnJlY3QgKyAxLFxuXHRcdFx0XHRcdHRvdGFsQ29ycmVjdDogZGF0YS50b3RhbENvcnJlY3QgKyAxLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlZERhdGE7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGluY1dyb25nQ291bnQ6IChyb3VuZCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnVwZGF0ZSgoZGF0YSkgPT4ge1xuXHRcdFx0aWYgKHJvdW5kID09PSAxKSB7XG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuXHRcdFx0XHRcdC4uLmRhdGEsXG5cdFx0XHRcdFx0cm91bmQxV3Jvbmc6IGRhdGEucm91bmQxV3JvbmcgKyAxLFxuXHRcdFx0XHRcdHRvdGFsV3Jvbmc6IGRhdGEudG90YWxXcm9uZyArIDEsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAocm91bmQgPT09IDIpIHtcblx0XHRcdFx0Y29uc3QgdXBkYXRlZERhdGEgPSB7XG5cdFx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0XHRyb3VuZDJXcm9uZzogZGF0YS5yb3VuZDJXcm9uZyArIDEsXG5cdFx0XHRcdFx0dG90YWxXcm9uZzogZGF0YS50b3RhbFdyb25nICsgMSxcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZWREYXRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRyZXNldFNjb3JlczogKCkgPT4ge1xuXHRcdGRuZF9zdG9yZV9kYXRhLnNldCh7XG5cdFx0XHR0b3RhbENvcnJlY3Q6IDAsXG5cdFx0XHR0b3RhbFdyb25nOiAwLFxuXHRcdFx0cm91bmQxQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMVdyb25nOiAwLFxuXHRcdFx0cm91bmQyQ29ycmVjdDogMCxcblx0XHRcdHJvdW5kMldyb25nOiAwLFxuXHRcdFx0Zmlyc3RMb2FkOiB0cnVlLFxuXHRcdH0pO1xuXHR9LFxuXHRjaGFuZ2VGaXJzdExvYWQ6IChuZXdCb29sKSA9PiB7XG5cdFx0ZG5kX3N0b3JlX2RhdGEudXBkYXRlKChkYXRhKSA9PiB7XG5cdFx0XHRjb25zdCB1cGRhdGVkRGF0YSA9IHtcblx0XHRcdFx0Li4uZGF0YSxcblx0XHRcdFx0Zmlyc3RMb2FkOiBuZXdCb29sLFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB1cGRhdGVkRGF0YTtcblx0XHR9KTtcblx0fSxcbn07XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0ZXhwb3J0IGxldCBjb2xIZWFkaW5ncztcblx0ZXhwb3J0IGxldCBwaWVjZXM7XG5cdGV4cG9ydCBsZXQgcm91bmQ7XG5cdGV4cG9ydCBsZXQgdGl0bGU7XG5cdGV4cG9ydCBsZXQgZG5kX3N0b3JlO1xuXHRsZXQgcGllY2VzQXJyYXkgPSBbXTtcblx0bGV0IHBpZWNlc0xlZnQgPSAzMDtcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0JDogaWYgKHBpZWNlc0xlZnQgPD0gMTUpIHtcblx0XHQvLyBpZiBjdXJyZW50IHJvdW5kIGlzIDEsIHRoZW4gY2hhbmdlIHRvIDIsIGVsc2UgY2hhbmdlIHRvIDNcblx0XHRyb3VuZCA9IHJvdW5kID09PSAxID8gMiA6IDM7XG5cdFx0ZGlzcGF0Y2goXCJjaGVja3JvdW5kXCIsIHJvdW5kKTtcblx0fVxuXHQkOiB7XG5cdFx0aWYgKCEkZG5kX3N0b3JlLmZpcnN0TG9hZCAmJiByb3VuZCA9PT0gMSkge1xuXHRcdFx0Ly8gcmVzZXQgb25seSBpZiBnYW1lIGhhcyBiZWVuIGxvYWRlZCBhbmQgdXNlciBpcyBiYWNrIHRvIHJvdW5kIDFcblx0XHRcdGRuZF9zdG9yZS5yZXNldFNjb3JlcygpO1xuXHRcdH1cblx0fVxuXHRvbk1vdW50KCgpID0+IHtcblx0XHRwaWVjZXNBcnJheSA9IFsuLi5waWVjZXNdO1xuXHRcdHBpZWNlc0FycmF5ID0gc2h1ZmZsZUFycmF5KHBpZWNlc0FycmF5KTtcblx0XHQvLyBmaXJzdExvYWQgc3RhcnRzIGFzIHRydWUsIGFuZCBpcyBpbW1lZGlhdGVseSB0dXJuZWQgZmFsc2Vcblx0XHQvLyB0aGlzIHdpbGwgYWZmZWN0IHNjb3JlIHJlc2V0IG9uTW91bnQgc28gdGhhdCByb3VuZCAyIGlzIG5vdCByZXNldFxuXHRcdC8vIGJ1dCByZXNldCB3aWxsIGhhcHBlbiB3aGVuIGNvbWluZyBiYWNrIGFmdGVyIGdhbWUgaXMgb3ZlclxuXHRcdGRuZF9zdG9yZS5jaGFuZ2VGaXJzdExvYWQoZmFsc2UpO1xuXHR9KTtcblx0Y29uc3Qgc2h1ZmZsZUFycmF5ID0gKGFycmF5KSA9PiB7XG5cdFx0Ly8gY29weSBhcnJheSB0byBtYW5pcHVsYXRlXG5cdFx0bGV0IGFycmF5Q29weSA9IFsuLi5hcnJheV07XG5cdFx0bGV0IG1peGVkQXJyYXkgPSBbXTtcblx0XHQvLyBsb29wIHRocm91Z2ggY29weSB1bnRpbCBubyBlbGVtZW50cyBsZWZ0XG5cdFx0d2hpbGUgKGFycmF5Q29weS5sZW5ndGggPiAwKSB7XG5cdFx0XHRsZXQgcmFuZE51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Q29weS5sZW5ndGgpO1xuXHRcdFx0Ly8gYWRkIHJlbW92ZWQgZWxlbWVudHMgdG8gbWl4ZWRBcnJheSBhcyBsb29waW5nIG9jY3Vyc1xuXHRcdFx0bWl4ZWRBcnJheS5wdXNoKGFycmF5Q29weS5zcGxpY2UocmFuZE51bSwgMSlbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWl4ZWRBcnJheTtcblx0fTtcblx0Y29uc3QgZHJhZ0l0ZW0gPSAoZSkgPT4ge1xuXHRcdGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIklNR1wiKSB7XG5cdFx0XHRlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBlLnRhcmdldC5wYXJlbnROb2RlLmlkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgZS50YXJnZXQuaWQpO1xuXHRcdH1cblx0fTtcblx0Y29uc3QgZHJvcEl0ZW0gPSAoZSkgPT4ge1xuXHRcdC8vIGRlZmluZSBwaWVjZXMgY29udGFpbmVyIHRvIGFsbG93IGRyb3Agb2YgaXRlbSBiYWNrIGludG8gb3JpZ2luYWwgc3BvdFxuXHRcdGxldCBpc1BpZWNlc0NvbnRhaW5lciA9IGhhc0NsYXNzKGUudGFyZ2V0LCBcInBpZWNlcy1jb250YWluZXJcIik7XG5cdFx0Ly8gbGV0IHBhcmVudCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0bGV0IGRyYWdJdGVtSWQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dFwiKTtcblx0XHRsZXQgZHJhZ0l0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmFnSXRlbUlkKTtcblx0XHQvLyBpZiB0YXJnZXQgdG8gZHJvcCBpbiBpcyBlbXB0eSBvciB0aGUgdGFyZ2V0IGlzIHRoZSBwaWNlcyBjb250YWluZXIsIHlvdSBjYW4gZHJvcCBpdGVtIGluXG5cdFx0aWYgKCFlLnRhcmdldC5maXJzdENoaWxkIHx8IGlzUGllY2VzQ29udGFpbmVyKSB7XG5cdFx0XHQvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCB0aGUgcGllY2VzIGNvbnRhaW5lclxuXHRcdFx0aWYgKCFpc1BpZWNlc0NvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBzZXR0aW5nIHRvIHN0YXRpYyBwb3NpdGlvbiBzbyB0aGUgZGl2IHdpbGwgYmUgcmVsYXRpdmUgdG8gcGFyZW50XG5cdFx0XHRcdGRyYWdJdGVtLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcblx0XHRcdFx0Ly8gbXVzdCBtYWtlIHZpc2libGUgYWdhaW4gYmVjYXVzZSBJIGFtIGhhZGRpbmcgYWxsIHN0YWNrZWQgcGllY2VzIGluXG5cdFx0XHRcdC8vIHRoZSBwaWVjZXMgY29udGFpbmVyIHRvIGRpc3BsYXkgb25seSB0aGUgdG9wIHBpZWNlIHNvIGFzIHRvIG5vdFxuXHRcdFx0XHQvLyBzdGFjayBib3gtc2hhZG93c1xuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHRoZSBvZGQgbnVtYmVyZWQgY2xhc3NlcyB0byBhZGp1c3QgZm9udCBjb2xvclxuXHRcdFx0XHRcdGhhc0NsYXNzKGUudGFyZ2V0LCBcImNvbDFcIikgfHxcblx0XHRcdFx0XHRoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2wzXCIpIHx8XG5cdFx0XHRcdFx0aGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sNVwiKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0ZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMGQyMjNmXCI7IC8vIG5hdnkgYmx1ZVxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjNzdiYzQzXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsIFwiY29sMlwiKSB8fCBoYXNDbGFzcyhlLnRhcmdldCwgXCJjb2w0XCIpKSB7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHRcdFx0XHRcdGUudGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzc3YmM0M1wiOyAvLyBncmVlblxuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmNvbG9yID0gXCIjMGQyMjNmXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjaGVja0lzTWF0Y2goZS50YXJnZXQsIGRyYWdJdGVtKSkge1xuXHRcdFx0XHRcdGRuZF9zdG9yZS5pbmNXcm9uZ0NvdW50KHJvdW5kKTtcblx0XHRcdFx0XHRlLnRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNiZjFkMWRcIjsgLy8gYmcgPSByZWRcblx0XHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5jb2xvciA9IFwiI2U4ZTFlMVwiOyAvLyBmb250IGNvbG9yID0gbGlnaHQgZ3JheVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNoZWNrSXNNYXRjaChlLnRhcmdldCwgZHJhZ0l0ZW0pKSB7XG5cdFx0XHRcdFx0ZG5kX3N0b3JlLmluY0NvcnJlY3RDb3VudChyb3VuZCk7XG5cdFx0XHRcdFx0Ly91c2luZyBjaGlsZHJlblswXSB3b3JrcyBmb3IgaW1hZ2UsIGJ1dCBJIGRvIHdhbnQgdG8gY2hlY2sgdGhlIG5vZGUsIG5vdCBqdXN0IGNoaWxkIGVsZW0uXG5cdFx0XHRcdFx0Ly8gc28gY2hpbGRyZW5bMF0gcmVzdWx0cyBpbiBicmVha1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZHJhZ0l0ZW1cIiwgZHJhZ0l0ZW0uY2hpbGRyZW4ubGVuZ3RoKTtcblx0XHRcdFx0XHRpZiAoZHJhZ0l0ZW0uY2hpbGROb2Rlc1swXS50YWdOYW1lID09PSBcIklNR1wiKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInRoaXMgaXMgYW4gaW1hZ2U6IFwiLCBkcmFnSXRlbSk7XG5cdFx0XHRcdFx0XHRkcmFnSXRlbS5jaGlsZE5vZGVzWzBdLnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLCBcImZhbHNlXCIpO1xuXHRcdFx0XHRcdFx0ZHJhZ0l0ZW0uY2hpbGROb2Rlc1swXS5zdHlsZS5jdXJzb3IgPSBcIm5vLWRyb3BcIjtcblx0XHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLm1heEhlaWdodCA9IFwiMTEwcHhcIjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIik7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYm9yZGVyID0gXCJub25lXCI7XG5cdFx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmJveFNoYWRvdyA9IFwibm9uZVwiO1xuXHRcdFx0XHRcdGRyYWdJdGVtLnN0eWxlLmN1cnNvciA9IFwibm8tZHJvcFwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGlzUGllY2VzQ29udGFpbmVyKSB7XG5cdFx0XHRcdC8vIGlmIGJlaW5nIHBsYWNlZCBiYWNrIGluIHRoZSBwaWVjZXMgY29udGFpbmVyLCBnb2luZyBiYWNrIHRvIGFic29sdXRlIGFuZCByZXNldHRpbmcgYmtncm5kICYgZm9udCBjb2xvclxuXHRcdFx0XHRkcmFnSXRlbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2IoMTE1LCAxNjcsIDE2NylcIjtcblx0XHRcdFx0ZHJhZ0l0ZW0uc3R5bGUuY29sb3IgPSBcInJnYigxNSwgMjEsIDIxKVwiO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHRoZSBhY3R1YWwgcGxhY2VtZW50IG9jY3Vyc1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZS50YXJnZXQuYXBwZW5kQ2hpbGQoZHJhZ0l0ZW0pO1xuXHRcdFx0bGV0IHBpZWNlc0NvbnQgPSByb3VuZCA9PT0gMSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGllY2VzQ29udDFcIikgOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBpZWNlc0NvbnQyXCIpO1xuXHRcdFx0cGllY2VzTGVmdCA9IGNoZWNrUGllY2VzTGVmdChwaWVjZXNDb250KTtcblx0XHR9XG5cdH07XG5cdGNvbnN0IGFsbG93RHJvcCA9IChlKSA9PiB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9O1xuXHRjb25zdCBoYW5kbGVEcmFnID0gKGUpID0+IHtcblx0XHRlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSBcImdyYWJiaW5nXCI7XG5cdH07XG5cdGNvbnN0IGNoZWNrSXNNYXRjaCA9ICh0YXJnZXQsIGRyYWdJdGVtKSA9PiB7XG5cdFx0aWYgKGhhc0NsYXNzKHRhcmdldCwgXCJjb2wxXCIpICYmIGhhc0NsYXNzKGRyYWdJdGVtLCBcImNvbDFcIikpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBcImNvbDJcIikgJiYgaGFzQ2xhc3MoZHJhZ0l0ZW0sIFwiY29sMlwiKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsIFwiY29sM1wiKSAmJiBoYXNDbGFzcyhkcmFnSXRlbSwgXCJjb2wzXCIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgXCJjb2w0XCIpICYmIGhhc0NsYXNzKGRyYWdJdGVtLCBcImNvbDRcIikpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBcImNvbDVcIikgJiYgaGFzQ2xhc3MoZHJhZ0l0ZW0sIFwiY29sNVwiKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cdGNvbnN0IGhhc0NsYXNzID0gKGVsLCBjbHNzKSA9PiB7XG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbHNzKTtcblx0fTtcblx0Y29uc3QgY2hlY2tQaWVjZXNMZWZ0ID0gKGVsKSA9PiB7XG5cdFx0Y29uc3QgbnVtQ2hpbGROb2RlcyA9IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuXHRcdHJldHVybiBudW1DaGlsZE5vZGVzO1xuXHR9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0QGltcG9ydCB1cmwoXCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PVNwYXJ0YW46d2dodEAxMDA7MjAwOzMwMDs0MDA7NTAwJmRpc3BsYXk9c3dhcFwiKTtcblx0KiB7XG5cdFx0Zm9udC1mYW1pbHk6IFwiU3BhcnRhblwiLCBzYW5zLXNlcmlmO1xuXHR9XG5cdC5nYW1lLXBhZ2Uge1xuXHRcdGhlaWdodDogNjUwcHg7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0bWluLXdpZHRoOiA4MzBweDtcblx0XHRtYXgtd2lkdGg6IDE1MDBweDtcblx0XHRtYXJnaW46IGF1dG87XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXHQuZ2FtZS1iYXIge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdG1hcmdpbjogMC43NXJlbTtcblx0fVxuXHQucGllY2VzLWNvbnRhaW5lciB7XG5cdFx0aGVpZ2h0OiAxNDVweDtcblx0XHQvKiB3aWR0aDogMjUlOyAqL1xuXHRcdHdpZHRoOiAzMDBweDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG5cdFx0YWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHR9XG5cdC5waWVjZXMge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiB0b3A7XG5cdFx0aGVpZ2h0OiAxMTBweDtcblx0XHRtYXgtd2lkdGg6IDkwJTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHQvKiBwYWRkaW5nLXRvcDogMTBweDsgKi9cblx0XHRwYWRkaW5nOiA1JSA1JSAwIDUlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICNkOGQ4ZDg7XG5cdFx0Y29sb3I6ICMzMTQ1NDE7XG5cdFx0bGluZS1oZWlnaHQ6IDEuMTVyZW07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGN1cnNvcjogZ3JhYjtcblx0XHRib3gtc2hhZG93OiAxcHggMnB4IDNweCBibGFjaztcblx0XHR2aXNpYmlsaXR5OiBoaWRkZW47XG5cdH1cblx0Lyogb25seSBzaG93IGZpcnN0IGRpdiBpbiBjb250YWluZXIgaGVscHMgcHJldmVudFxuICBzdGFja2luZyB1cCBvZiBib3gtc2hhZG93XG4gIE5PVEU6IG1ha2Ugc3VyZSB0byBoYXZlIGFueSBkcm9wcGVkIGRpdnMgaW4gdGFyZ2V0cyB2aXNpYmxlICovXG5cdC5waWVjZXMtY29udGFpbmVyIGRpdjpmaXJzdC1vZi10eXBlIHtcblx0XHR2aXNpYmlsaXR5OiB2aXNpYmxlO1xuXHR9XG5cdC5waWVjZXM6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcblx0XHRkaXNwbGF5OiBub25lO1xuXHR9XG5cdC5waWVjZXMudGV4dCB7XG5cdFx0b3ZlcmZsb3c6IGF1dG87XG5cdH1cblx0LmltZy1jb250YWluZXIge1xuXHRcdG1heC1oZWlnaHQ6IDEzMHB4O1xuXHRcdHBhZGRpbmc6IDFweDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGJveC1zaGFkb3c6IDFweCAycHggM3B4IGJsYWNrO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdH1cblx0LmltZy1waWVjZSB7XG5cdFx0LyogbWF4LWhlaWdodDogMTIwcHg7ICovXG5cdFx0bWF4LWhlaWdodDogOTAlO1xuXHRcdC8qIGhlaWdodDogYXV0bzsgKi9cblx0XHQvKiBtYXgtd2lkdGg6IDEwMCU7ICovXG5cdFx0bWluLXdpZHRoOiA3NXB4O1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdG1hcmdpbjogMCA1cHg7XG5cdFx0Lyogd2lkdGg6IDkwJTsgKi9cblx0fVxuXHQuc2NvcmUtY29udGFpbmVyIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXHR9XG5cdC5zY29yZS1pdGVtIHtcblx0XHRtYXJnaW4tYm90dG9tOiAwLjZyZW07XG5cdH1cblx0LnJvdW5kLWxhYmVsIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0aGVpZ2h0OiAxMTRweDtcblx0XHRmb250LXNpemU6IDNyZW07XG5cdH1cblx0LnRhcmdldC1jb250YWluZXIge1xuXHRcdGhlaWdodDogNzAlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcblx0XHRmbGV4LXdyYXA6IHdyYXA7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRtYXJnaW46IDA7XG5cdH1cblx0LnRhcmdldCB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRoZWlnaHQ6IDEzMHB4O1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdG1hcmdpbjogMDtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXHQuY29sdW1uIHtcblx0XHR3aWR0aDogMTklO1xuXHRcdG1heC1oZWlnaHQ6IDEwMCU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0bWFyZ2luOiAwIDAuMjVyZW07XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblx0LmMxIC50YXJnZXQsXG5cdC5jMyAudGFyZ2V0LFxuXHQuYzUgLnRhcmdldCB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogIzBkMjIzZjtcblx0XHRjb2xvcjogIzc3YmM0Mztcblx0fVxuXHQuYzIgLnRhcmdldCxcblx0LmM0IC50YXJnZXQge1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICM3N2JjNDM7XG5cdFx0Y29sb3I6ICMwZDIyM2Y7XG5cdH1cblx0LmNvbEhlYWRpbmcge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRtYXJnaW46IDA7XG5cdFx0aGVpZ2h0OiAzNXB4O1xuXHRcdGZvbnQtc2l6ZTogMXJlbTtcblx0fVxuXHQuYzEgLmNvbEhlYWRpbmcsXG5cdC5jMyAuY29sSGVhZGluZyxcblx0LmM1IC5jb2xIZWFkaW5nIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjNzdiYzQzO1xuXHR9XG5cdC5jMiAuY29sSGVhZGluZyxcblx0LmM0IC5jb2xIZWFkaW5nIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjMGQyMjNmO1xuXHRcdGNvbG9yOiAjNzdiYzQzO1xuXHR9XG5cdEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDExMjBweCkge1xuXHRcdC5waWVjZXMtY29udGFpbmVyIHtcblx0XHRcdG1hcmdpbi1sZWZ0OiA4cHg7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT57dGl0bGV9PC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxkaXYgY2xhc3M9XCJnYW1lLXBhZ2VcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0+XG5cdDxkaXYgY2xhc3M9XCJ0YXJnZXQtY29udGFpbmVyXCI+XG5cdFx0PGRpdiBjbGFzcz1cImNvbHVtbiBjMVwiPlxuXHRcdFx0PGgzIGNsYXNzPVwiY29sSGVhZGluZ1wiPntjb2xIZWFkaW5ncy5jb2wxSGVhZGluZ308L2gzPlxuXHRcdFx0PGRpdiBpZD1cInQxXCIgY2xhc3M9XCJ0YXJnZXQgY29sMVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQyXCIgY2xhc3M9XCJ0YXJnZXQgY29sMVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQzXCIgY2xhc3M9XCJ0YXJnZXQgY29sMVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4gYzJcIj5cblx0XHRcdDxoMyBjbGFzcz1cImNvbEhlYWRpbmdcIj57Y29sSGVhZGluZ3MuY29sMkhlYWRpbmd9PC9oMz5cblx0XHRcdDxkaXYgaWQ9XCJ0NFwiIGNsYXNzPVwidGFyZ2V0IGNvbDJcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0NVwiIGNsYXNzPVwidGFyZ2V0IGNvbDJcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0NlwiIGNsYXNzPVwidGFyZ2V0IGNvbDJcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiY29sdW1uIGMzXCI+XG5cdFx0XHQ8aDMgY2xhc3M9XCJjb2xIZWFkaW5nXCI+e2NvbEhlYWRpbmdzLmNvbDNIZWFkaW5nfTwvaDM+XG5cdFx0XHQ8ZGl2IGlkPVwidDdcIiBjbGFzcz1cInRhcmdldCBjb2wzXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDhcIiBjbGFzcz1cInRhcmdldCBjb2wzXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDlcIiBjbGFzcz1cInRhcmdldCBjb2wzXCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImNvbHVtbiBjNFwiPlxuXHRcdFx0PGgzIGNsYXNzPVwiY29sSGVhZGluZ1wiPntjb2xIZWFkaW5ncy5jb2w0SGVhZGluZ308L2gzPlxuXHRcdFx0PGRpdiBpZD1cInQxMFwiIGNsYXNzPVwidGFyZ2V0IGNvbDRcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTFcIiBjbGFzcz1cInRhcmdldCBjb2w0XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDEyXCIgY2xhc3M9XCJ0YXJnZXQgY29sNFwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJjb2x1bW4gYzVcIj5cblx0XHRcdDxoMyBjbGFzcz1cImNvbEhlYWRpbmdcIj57Y29sSGVhZGluZ3MuY29sNUhlYWRpbmd9PC9oMz5cblx0XHRcdDxkaXYgaWQ9XCJ0MTNcIiBjbGFzcz1cInRhcmdldCBjb2w1XCIgb246ZHJvcD17ZHJvcEl0ZW19IG9uOmRyYWdvdmVyPXthbGxvd0Ryb3B9IC8+XG5cdFx0XHQ8ZGl2IGlkPVwidDE0XCIgY2xhc3M9XCJ0YXJnZXQgY29sNVwiIG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfSAvPlxuXHRcdFx0PGRpdiBpZD1cInQxNVwiIGNsYXNzPVwidGFyZ2V0IGNvbDVcIiBvbjpkcm9wPXtkcm9wSXRlbX0gb246ZHJhZ292ZXI9e2FsbG93RHJvcH0gLz5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cblx0PGRpdiBjbGFzcz1cImdhbWUtYmFyXCI+XG5cdFx0PGRpdiBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogMTAgfX0gY2xhc3M9XCJzY29yZS1jb250YWluZXJcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJzY29yZS1pdGVtXCI+dG90YWwgY29ycmVjdDogeyRkbmRfc3RvcmUudG90YWxDb3JyZWN0fTwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cInNjb3JlLWl0ZW1cIj50b3RhbCB3cm9uZzogeyRkbmRfc3RvcmUudG90YWxXcm9uZ308L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJzY29yZS1pdGVtXCI+cm91bmQge3JvdW5kfSBjb3JyZWN0OiB7cm91bmQgPT09IDEgPyAkZG5kX3N0b3JlLnJvdW5kMUNvcnJlY3QgOiAkZG5kX3N0b3JlLnJvdW5kMkNvcnJlY3R9PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2NvcmUtaXRlbVwiPnJvdW5kIHtyb3VuZH0gd3Jvbmc6IHtyb3VuZCA9PT0gMSA/ICRkbmRfc3RvcmUucm91bmQxV3JvbmcgOiAkZG5kX3N0b3JlLnJvdW5kMldyb25nfTwvZGl2PlxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInJvdW5kLWxhYmVsXCIgb3V0OmZhZGU9e3sgZHVyYXRpb246IDEwIH19PlJvdW5kIHtyb3VuZH08L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJwaWVjZXMtY29udGFpbmVyXCIgaWQ9e3JvdW5kID09PSAxID8gJ3BpZWNlc0NvbnQxJyA6ICdwaWVjZXNDb250Mid9IG9uOmRyb3A9e2Ryb3BJdGVtfSBvbjpkcmFnb3Zlcj17YWxsb3dEcm9wfT5cblx0XHRcdHsjZWFjaCBwaWVjZXNBcnJheSBhcyBwaWVjZSwgaX1cblx0XHRcdFx0eyNpZiBwaWVjZS5kZWZpbml0aW9uIHx8IHBpZWNlLmhpbnR9XG5cdFx0XHRcdFx0PGRpdiBpbjpmYWRlIGlkPXtwaWVjZS5pZH0gY2xhc3M9e2BwaWVjZXMgJHtwaWVjZS5jb2x9IHRleHRgfSBkcmFnZ2FibGU9XCJ0cnVlXCIgb246ZHJhZ3N0YXJ0PXtkcmFnSXRlbX0+XG5cdFx0XHRcdFx0XHR7cGllY2UuZGVmaW5pdGlvbiA/IHBpZWNlLmRlZmluaXRpb24gOiBwaWVjZS5oaW50fVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0PGRpdiBpbjpmYWRlIGlkPXtwaWVjZS5pZH0gY2xhc3M9e2BwaWVjZXMgJHtwaWVjZS5jb2x9IGltZy1jb250YWluZXJgfSBkcmFnZ2FibGU9XCJ0cnVlXCI+XG5cdFx0XHRcdFx0XHQ8aW1nIGNsYXNzPVwiaW1nLXBpZWNlXCIgc3JjPXtwaWVjZS5waWN9IGFsdD17cGllY2UuYWx0fSBvbjpkcmFnc3RhcnQ9e2RyYWdJdGVtfSBvbjpkcmFnPXtoYW5kbGVEcmFnfSAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0ey9lYWNofVxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IGxldCB0b3RhbENvcnJlY3Q6IG51bWJlcjtcblx0ZXhwb3J0IGxldCB0b3RhbFdyb25nOiBudW1iZXI7XG5cblx0bGV0IGZpbmFsU2NvcmU6IG51bWJlcjtcblx0JDoge1xuXHRcdGxldCBjYWxjU2NvcmUgPSBNYXRoLnJvdW5kKCgoMzAgLSB0b3RhbFdyb25nKSAvIDMwKSAqIDEwMCk7XG5cdFx0ZmluYWxTY29yZSA9IGNhbGNTY29yZSA+PSAwID8gY2FsY1Njb3JlIDogMDtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LmdhbWUtb3Zlcl9jb250YWluZXIge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogNTB2aDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtd3JhcDogd3JhcDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHR9XG5cdC50aXRsZSB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG5cdC5zY29yZS1jb250ZW50IHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJnYW1lLW92ZXJfY29udGFpbmVyXCI+XG5cdDxoMSBjbGFzcz1cInRpdGxlXCI+R2FtZSBPdmVyPC9oMT5cblx0PGg0IGNsYXNzPVwic2NvcmUtY29udGVudFwiPlRvdGFsIENvcnJlY3Q6IHt0b3RhbENvcnJlY3R9PC9oND5cblx0PGg0IGNsYXNzPVwic2NvcmUtY29udGVudFwiPlRvdGFsIFdyb25nOiB7dG90YWxXcm9uZ308L2g0PlxuXHQ8aDQgY2xhc3M9XCJzY29yZS1jb250ZW50XCI+RmluYWwgU2NvcmU6IHtmaW5hbFNjb3JlfTwvaDQ+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGRuZF9zdG9yZSB9IGZyb20gXCIuLi9zdG9yZXMvZG5kX2dhbWVfc3RvcmVcIjtcblx0aW1wb3J0IEdhbWVCb2FyZCBmcm9tIFwiLi9HYW1lQm9hcmQuc3ZlbHRlXCI7XG5cdGltcG9ydCB7IGZhZGUsIGZseSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xuXHRpbXBvcnQgR2FtZU92ZXIgZnJvbSBcIi4vR2FtZU92ZXIuc3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBkbmRfY29udGVudDtcblx0Ly8gVFMvU3ZlbHRlIHJlcXVpcmVzIHRoaXMgcGF0dGVybiBmb3IgcmVhY3RpdmUgZGVjbGFyYXRpb25zIChodHRwczovL2Jsb2cuc2NvdHRsb2dpYy5jb20vMjAyMC8wNy8yNC9zdmVsdGUtdHMuaHRtbClcblx0bGV0IHVwZGF0ZWRSb3VuZDogbnVtYmVyO1xuXHQkOiB1cGRhdGVkUm91bmQgPSAxO1xuXG5cdGludGVyZmFjZSBDb2xIZWFkaW5ncyB7XG5cdFx0Y29sMUhlYWRpbmc6IHN0cmluZztcblx0XHRjb2wySGVhZGluZzogc3RyaW5nO1xuXHRcdGNvbDNIZWFkaW5nOiBzdHJpbmc7XG5cdFx0Y29sNEhlYWRpbmc6IHN0cmluZztcblx0XHRjb2w1SGVhZGluZzogc3RyaW5nO1xuXHR9XG5cdGxldCBjb2xIZWFkaW5nczogQ29sSGVhZGluZ3M7XG5cdCQ6IGNvbEhlYWRpbmdzID0gdXBkYXRlZFJvdW5kID09PSAxID8gZG5kX2NvbnRlbnQuZG5kZ2FtZTEgOiBkbmRfY29udGVudC5kbmRnYW1lMjtcblx0JDogcGllY2VzID0gdXBkYXRlZFJvdW5kID09PSAxID8gZG5kX2NvbnRlbnQucGllY2VzMSA6IGRuZF9jb250ZW50LnBpZWNlczI7XG5cdCQ6IHJvdW5kID0gdXBkYXRlZFJvdW5kO1xuXG5cdGNvbnN0IHVwZGF0ZVJvdW5kID0gKGUpID0+IHtcblx0XHR1cGRhdGVkUm91bmQgPSBlLmRldGFpbDtcblx0fTtcbjwvc2NyaXB0PlxuXG57I2lmIHVwZGF0ZWRSb3VuZCA9PT0gMX1cblx0PGRpdiBpbjpmYWRlPXt7IGR1cmF0aW9uOiAzMDAgfX0gb3V0OmZhZGU9e3sgZHVyYXRpb246IDUwMCB9fT5cblx0XHQ8R2FtZUJvYXJkIHtkbmRfc3RvcmV9IHRpdGxlPXtkbmRfY29udGVudC50aXRsZX0ge2NvbEhlYWRpbmdzfSB7cGllY2VzfSBvbjpjaGVja3JvdW5kPXt1cGRhdGVSb3VuZH0ge3JvdW5kfSAvPlxuXHQ8L2Rpdj5cbns6ZWxzZSBpZiB1cGRhdGVkUm91bmQgPT09IDJ9XG5cdDxkaXYgaW46ZmFkZT17eyBkZWxheTogNjAwLCBkdXJhdGlvbjogNTAwIH19IG91dDpmbHk9e3sgeDogMjAwLCBkdXJhdGlvbjogNTAwIH19PlxuXHRcdDxHYW1lQm9hcmQge2RuZF9zdG9yZX0gdGl0bGU9e2RuZF9jb250ZW50LnRpdGxlfSB7Y29sSGVhZGluZ3N9IHtwaWVjZXN9IG9uOmNoZWNrcm91bmQ9e3VwZGF0ZVJvdW5kfSB7cm91bmR9IC8+XG5cdDwvZGl2PlxuezplbHNlIGlmIHVwZGF0ZWRSb3VuZCA9PT0gM31cblx0PGRpdiBpbjpmbHk9e3sgeTogMjAwLCBkZWxheTogNjAwIH19PlxuXHRcdDxHYW1lT3ZlciB0b3RhbENvcnJlY3Q9eyRkbmRfc3RvcmUudG90YWxDb3JyZWN0fSB0b3RhbFdyb25nPXskZG5kX3N0b3JlLnRvdGFsV3Jvbmd9IC8+XG5cdDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZChwYWdlLCBzZXNzaW9uKSB7XG5cdFx0Y29uc3QgeyBkbmRfdW5pdCB9ID0gcGFnZS5wYXJhbXM7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaChgZGF0YS8ke2RuZF91bml0fS5qc29uYCk7XG5cdFx0Y29uc3QgZG5kX2NvbnRlbnQgPSBhd2FpdCByZXMuanNvbigpO1xuXHRcdHJldHVybiB7IGRuZF9jb250ZW50IH07XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgRG5EIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL0RuRC5zdmVsdGVcIjtcblx0ZXhwb3J0IGxldCBkbmRfY29udGVudDsgLy8gdGhpcyBnZXRzIGRlZmluZWQgaW4gc2NyaXB0IG1vZHVsZSBhYm92ZVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPntkbmRfY29udGVudC50aXRsZX08L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPERuRCB7ZG5kX2NvbnRlbnR9IC8+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDO0FBQ2hDLENBQUMsWUFB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
